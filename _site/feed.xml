<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>追梦抓梦</title>
    <description></description>
    <link>https://bbel.ink/</link>
    <atom:link href="https://bbel.ink/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 13 Oct 2019 12:20:18 +0800</pubDate>
    <lastBuildDate>Sun, 13 Oct 2019 12:20:18 +0800</lastBuildDate>
    <generator>Jekyll v3.1.1</generator>
    
      <item>
        <title>FPGA</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;对照表&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;简称&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;全称&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;中文&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;SSI&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;小规模集成电路&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;MSI&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;中规模集成电路&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;VLSI&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;超大规模集成电路&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;GSI&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;巨大规模集成电路&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ASIC&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;微处理器&amp;amp;专用集成电路&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;LSI&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;通用全硬件LSI电路&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;PLD&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;可编程逻辑器件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;SSI&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;MSI&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;IC&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;EDA&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;软件仿真工具&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;简单低密度PLD器件&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;———-&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;PROM&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;可编程只读存储器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;EPROM&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;紫外线可擦除只读存储器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;E²PROM&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;电可擦除只读存储器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;PAL&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;可编程阵列逻辑&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;GAL&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;通用阵列逻辑&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;复杂高密度PLD器件&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;———-&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;FPGA&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;File Programmable Gate Array&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;现场可编程门阵列（硬件仿真）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;CPLD&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Complex Programmable Logic Device&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;复杂可编程逻辑器件（硬件仿真）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;RTL&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Register Transformation Level&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;寄存器传输级&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;CFI&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;CAD Framework International&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;国际计算机辅助设计框架结构组织&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;IP Core&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Intellectual Property Core&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;致使产权芯核&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;CPU&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;中央处理器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;DSP&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;数字信号处理器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;PCI&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;外设接口&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;EDO&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;电子系统最优化&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;IRL&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Internet Reconfigurable Logic&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;互联网可重构逻辑&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;SOC&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;System on a Chip&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;片上系统&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;SOPC&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;System on a Programmable Chip&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;片上可编程系统&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;IC&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;集成电路&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;IS&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;集成系统&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;       为了避免设计的风险，在开发新的系统时常常采用FPGA/CPLD进行初步设计以验证系统设计的正确性，这已成为一种标准的方法。在设计过程中，往往先利用EDA工具完成软件仿真，再利用可编程ASIC器件FPGA/CPLD进行硬件仿真，在可编程ASIC器件实现设计后，通过版图设计、芯片测试、制版和流片转成ASIC电路。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;软件硬化，硬件软化&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;       软件硬化是指所有的软件设计最后转化成硬件来实现，用软件方式设计的系统到硬件系统的转换是由EDA开发软件自动完成的； &lt;br /&gt;
       硬件软化是指硬件的设计是用软件的设计方式进行，尽管目标系统是硬件，但整个设计和修改过程如同完成软件设计一样方便和高效。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;top-down&quot;&gt;自顶向下(top-down)的设计方法&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;       传统的设计方法都是自底向上的，即首先确定可用的元器件，然后根据这些器件进行逻辑设计，完成各模块后进行连接，并形成系统，最后经调试、测量看整个系统是否达到规定的性能指标。  &lt;br /&gt;
        基于EDA技术的所谓“自顶向下”的设计方法正好相反，它主要采用并行工程和“自顶向下”的设计方法，使开发者从一开始就要考虑到产品生成周期的诸多方面，包括质量、成本、开发时间及用户的需求等。该设计方法首先从系统设计入手，在顶层进行功能划分和结构设计，由于采用高级语言描述，因此能在系统级采用仿真手段验证设计的正确性，然后再逐级设计底层的结构，用VHDL、Verilog HDL 等硬件描述语言对高层次的系统进行电路描述，最后再用逻辑综合优化工具生成具体的门级逻辑电路的网表，其对应的物理实现级可以是印刷电路板或专用集成电路。“自定向下”设计方法的特点表现在以下几个方面： &lt;br /&gt;
        （1）基于可编程逻辑器件PLD和EDA开发工具支撑 &lt;br /&gt;
        （2）采用系统级、电路级和门级的逐级仿真技术，以便及早发现问题，进而修改设计方案。 &lt;br /&gt;
        （3）现代电子应用正向模块化发展，或者说向软、硬组合的方向发展。对于以往的设计成果稍作修改、组合就能投入再利用，从而产生全新或派生的设计模块 &lt;br /&gt;
        （4）由于采用的是结构化开发手段，所以可实现多人多任务的并行工作方式，使复杂系统的设计规模和效率大幅度提高。 &lt;br /&gt;
        （5）再选择器件的类型、规模、硬件结构等方面具有更大的自由度。
### 集设计、仿真和测试于一体
       现代的EDA软件平台集设计、仿测试于一体，配备了系统设计自动化的全部工具，这些工具包括：多种能兼容和混合使用的逻辑描述输入工具以及高性能的逻辑综合、优化和仿真测试工具。电子设计师可以从概念、算法、协议等开始设计电子系统，将电子产品从电路、性能分析到设计出IC版图或PCB版图的整个过程在计算机上自动完成。 &lt;br /&gt;
       EDA 仿真测试技术极大地提高了大规模系统电子设计的自动化程度。在设计的各个阶段都能方便地进行仿真和测试。设计的输入、输出或中间变量之间的信号关系由计算机根据要求提供的设计方案，从各种不同层次的系统性能出发完成一系列准确额逻辑和时序仿真验证。该测试技术通过计算机就能对系统上的目标器件进行边界扫描测试。目前大部分FPGA/CPLD芯片都支持边界扫描技术。边界扫描测试技术标准是由IEEE（电气工程师学会）组织联合测试行动组（JTAG）在20世纪80年代提出的，用来解决高密度引线器件和高密度电路板上的元器件的测试问题。它只需要四根信号线就能够对电路板上所有支持边界扫描的芯片内部逻辑和边界管脚进行测试。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-2&quot;&gt;在系统可现场编程，在线升级&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;        编程是指把系统设计的程序化数据按一定的格式转入一个或多个可编程逻辑器件的编程存储单元，定义内部模块的逻辑功能以及它们的相互连接关系。早期的可编程逻辑器件需要将芯片从印制板上拆下，然后把它插在专用的编程器上进行编程，目前广泛采用的在系统可编程技术则克服了这一缺点。 &lt;br /&gt;
        在系统可编程是指可编程逻辑器件不需要使用编程器，具有将器件插在系统内或电路板上仍然可以对其进行编程和再编程的能力。目前的FPGA/CPLD器件为设计者提供了系统内可再编程或可再配置能力，使得系统内硬件的功能可以像软件一样易于修改，这就为设计者进行电子系统设计和开发提供了可实现的最新手段。采用这种技术对系统的设计、制造、测试和维护也产生了重大的影响，给样机设计、电路板调试、系统制造和系统升级带来革命性的变化。
### 设计工作标准化，模块可移植共享
       设计语言、EDA的底层技术及其接口的标准化能很好地对设计结果进行交换、共享及重用。数据格式的一致性通过标准来保证。EDA的底层技术、EDA软件之间的接口等采用标准数据格式，这样管理局特色的EDA工具都能被集成在易于管理的统一环境之下，并支持任务之间、项目之间、设计工程师之间的信息传输和工程数据共享，从而使EDA框架日趋标准化并进行设计工作和“自顶向下”设计方法也是构建电子系统集成设计环境或集成设计平台的基本规范。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;eda&quot;&gt;传统设计方法和EDA设计方法的主要区别&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;传统设计方法&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;EDA设计方法&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;自底向上&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;自顶向下&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;手动设计&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;自动设计&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;硬、软件分离&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;打破硬、软件屏障&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;原理图方式设计&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;原理图、VHDL语言等多种设计方式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;系统功能固定&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;系统功能了易变&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;不易仿真&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;易仿真&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;难测试修改&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;易测试修改&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;模块难移植共享&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;设计工作标准化，模块可移植共享&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;设计周期长&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;设计周期短&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-3&quot;&gt;现代数字系统的设计流程&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;       现代数字系统的设计流程是指利用EDA软件和编程工具对可编程逻辑器件进行开发的过程。在EDA软件平台上，利用硬件描述语言HDL等逻辑描述手段完成设计，然后结合多层次的仿真技术，在确保设计的可行性与正确性的前提下完成功能确认，接着日用EDA工具的逻辑综合功能，把功能描述转换成某一具体目标芯片的网表文件，输出给该器件厂商的布局布线适配器，进行逻辑化简及优化、逻辑映射及布局布线，再利用产生的仿真文件进行功能和时序等方面的验证，以确保实际系统的性能，最后，进行针对特定目标芯片的逻辑映射和编程下载等工作。整个过程包括 &lt;br /&gt;
- 设计准备
- 设计输入
- 设计处理
- 器件编程
四个步骤以及相应的功能仿真、时序仿真和器件测试三个设计校验过程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;现代数字系统的设计流程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
设计准备   
    |   
    |   
设计输入 ————&amp;gt; 功能仿真   
    |   &amp;lt;————   
    |   
    |   
设计处理 ————&amp;gt; 时序仿真   
    |   &amp;lt;————   
    |     
    |    
器件编程 ————&amp;gt; 器件测试   
        &amp;lt;————   
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;设计准备&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;       在设计之前，首先要进行方案论证、系统设计和器件选择等设计准备工作。设计者首先根据任务要求，判明系统指标的可行性。系统的可行性要受到逻辑合理性、成本、开发条件、器件供应、设计员水平等方面的约束。若系统可行，则根据系统所完成的功能及复杂程度，对器件本身的资源和成本、工作速度及连线的可布性等方面进行权衡，选择合适的设计方案和合适的器件类型。
### 设计输入
       设计输入是设计者将所设计的系统或电路以EDA开发软件要求的某种形式表示出来，并送入计算机的过程。他根据EDA开发系统提供的一个电路逻辑的输入环境（如原理图、硬件描述语言HDL等形式）进行输入，这些方法可以单独构成，也可将多种手段组合来生成一个完整的设计。 &lt;br /&gt;
       输入软件在设计输入时，还会检查语法错误，并产生网表文件，供设计处理和设计校验使用。
### 设计处理
       设计处理是从设计输入文件到生成编程数据文件的编译过程，这是器件设计中的核心环节。设计处理是由编译软件自动完成的。设计处理的过程如下。 &lt;br /&gt;
       （1）逻辑优化和综合。由软件化简逻辑，并把逻辑描述转变为最适合在器件中实现的形式。综合的目的是将多个模块化设计文件并为一个网表文件，并使层次设计平面化。逻辑综合应施加合理的用户约束，以满足设计的要求。
       （2）映射。把设计分为多个适用具体PLD器件内部逻辑资源实现的逻辑小块的形式。映射工作可以全部自动实现，也可以部分由用户控制，还可以全部由用户控制进行。 &lt;br /&gt;
       （3）布局和布线。布局和布线工作是在设计检验通过以后由软件自动完成的，它能以最优的方式对逻辑元件进行布局，并准确地实现PLD器件内部逻辑元器件的互连。 &lt;br /&gt;
       （4）生成编程数据文件。设计处理的最后一步是产生可供器件编程使用的数据文件。对CPLD器件而言，产生熔丝图文件即JDEC文件，对FPGA器件则生成位流数据文件。
### 数据校验
       设计校验过程是使用EDA开发软件对设计进行分析，它包括功能仿真、时序仿真和器件测试。 &lt;br /&gt;
        功能仿真用于验证设计的逻辑功能，通常是在设计输入完成之后，选择具体器件进行编译之前进行的逻辑功能验证。功能仿真没有延时信息，对于初步的逻辑功能检测非常方便。仿真结果将会生成报告文件和信号波形输出，从中便可以观察到各个节点的信号变化。若发现错误，则可返回设计输入中修改逻辑设计。 &lt;br /&gt;
       时序仿真是在选择了具体器件并完成布局、布线之后进行的快速时序检验，可对设计性能作整体上的分析，这也是与实际器件工作情况基本相同的仿真。由于不同器件的内部延时不一样，不同的布布线方案也给延时造成不同的影响，用户可以得到某一条或某一类路径的时延信息，时序仿真也可以给出所有路径的延时信息（又称延时仿真）。若设计的性能不能达到要求，需找出影响性能的关键路径，并返回延时信息，修改约束文件，对设计进行重新综合和布局布线，如此重复多次知道满足设计要求为止。因此时序仿真对于分析时序关系，评估设计的性能以及检查和消除竞争冒险等是非常有必要的。  &lt;br /&gt;
       直接进行功能仿真合理有点是设计耗时短，对硬件库和综合器没有任何要求，尤其对于规模比较大的的设计项目，综合布局布线在计算机运行耗时可观，若每次修改都进行时序仿真，显然会降低设计开发效率。通常的做法是：首先进行功能仿真，待确认设计文件满足设计要求的逻辑功能后再进行综合、布局布线和时序仿真，把握设计项目在实际器件的工作情况。
### 器件编程
       编程是吧系统设计的下载或配置文件，通过编程电缆按一定的格式装入一个或多个PLD的编程存储单元，用于定义PLD内部模块的逻辑功能以及它们的相互连接关系，以便进行硬件调试和器件测试。 &lt;br /&gt;
       器件编程需要满足一定的条件，如编程电压、编程时序和编程算法等。随着PLD集成度不断提高，PLD的编程日益复杂，PLD的编程必须在开发系统的支持下才能完成。 &lt;br /&gt;
        器件编程在完毕后，对于具有边界扫描测试能力和在系统编程能力的器件来说，系统测试起来就更加方便，他可通过下载电缆下载测试数据来探测芯片的内部逻辑以诊断设计，并能随时修改设计重新编程。
### EDA软件工具简介
* EDA 软件工具分为如下5个模块&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;模块&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;简介&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;模块一&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;设计输入编辑器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;模块二&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;HDL综合器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;模块三&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;仿真器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;模块四&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;适配器（或称布局、布线器）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;模块五&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;下载器（或称编程器）&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;现在也有将五个模块集成在一起的EDA开发软件,如Xilinx公司的ISE、Altera公司的Quartus II软件。
### 设计输入编辑器
       优秀的EDA软件平台不仅集成了多种输入编辑器的设计输入表达式，如状态图输入方式、波形输入方式以及HDL的文本输入方式，而且还提供了不同的设计平台之间的信息交流接口和一定数量的功能模块库供设计人员直接选用。设计者可以根据功能模块的具体情况灵活选用。
- 原理图输入
       原理图输入时EDA工具软件提供的最基本的设计方法。该方法是选用EDA软件提供的器件库资源，并利用电路作图的方法，进行相关的电气连接而构成相应的系统或满足某些特定功能的系统或新元件。这种方式大多在对系统及各部分电路很熟悉的情况，或在系统对时间特性要求较高的场合，它的主要优点是容易实现仿真，便于信号的观察和电路的调整。原理图设计方法直观、易学。但当系统功能较复杂时，原理图输入方式效率低，他适合应于不太复杂的小系统和复杂系统的综合设计（与其他设计方法进行联合设计）。
- 程序设计法
       程序设计法是指使用硬件描述语言HDL进行电路设计，使用HDL语言描述硬件电路是解决复杂电路描述的重要手段，大规模和超大规模集成电路均要使用HDL进行设计，硬件描述语言种类较多，使用较多的主要有ABEL、VHDL和Verilog HDL。由于VHDL和Verilog HDL 被国际IEEE组织认定为工业标准硬件描述语言，目前这两种语言在电子设计领域得到了广泛的应用。 &lt;br /&gt;
- 状态机
       一些EDA设计输入工具提供状态机图形设计描述方法。用户可用可视化图形（状态图）来描述状态机，可以绘画似的创建一定功能的状态机，最后生成HDL文本输入，如Mentor公司的FPGA advantage(含 HDL designer series)、Active HDL 中的Active State 等。尤其是HDL designer series 中的各种输入编辑器，可以接受诸如原理图、状态图、表格图等输入形式。  &lt;br /&gt;
- IP模块使用
       使用具有知识产权的IP模块是现代数字系统设计中最有效的方法之一。IP模块也称为IP Core (Intellectual Property Core)，即致使产权芯核。 &lt;br /&gt;
       IP模块或IP Core 一般是比较复杂的模块，如中央处理器（CPU）、数字信号处理器（DSP）、外设接口（PCI）等，这类模块设计工作量大，设计者要在设计、仿真、优化、逻辑综合、测试等方面花费大量劳动。供应商在提供IP模块时，已经排除了语言描述的冗余性，并且经过了验证，所以系统设计者采用IP模块进行设计时，可以集中精力去解决系统中的重点课题，并可以将优化合理IP模块合并到其核心电路中来进行逻辑合成。另外，除了EDA软件工具提供大量IP Core以外，网络上也有丰富的各类IP Core 出售，甚至提供成套解决方案，使设计者之间资源共享，从而缩短了产品设计周期，降低了产品设计风险。 &lt;br /&gt;
       在设计输入过程中，往往分模块、分层次地进行设计描述。描述器件总功能的模块放置在最上层，称为顶层设计；描述器件最基本功能的模块放置在最下层，称为底层设计。层次化设计方法比较自由，可以在任何层次使用电路图或HDL进行描述。由于电路图的特点是适合描述连接关系和接口关系，而描述逻辑功能则很繁琐；HDL语言正好相反，逻辑描述能力强，但不适合描述链接和接口关系。一般常见的做法是：在顶层设计中，使用电路图描述模块连接关系和芯片内部逻辑到管脚的接口；在底层设计中，使用HDL硬件描述语言描述模块的逻辑功能。 &lt;br /&gt;
       现代EDA软件为设计者提供了多种有效的设计入口，但是各种设计方法都有其自身的优势和局限。合理选择和综合应用各种设计方法尤其是IP Core 和网上资源常常会使设计工作事半功倍。
### HDL综合器
       逻辑综合就是使用EDA综合工具，将HDL语言描述的寄存器传输级电路转化成门级网表的过程。逻辑综合是一个中间过程，它生成的网表是由用导线相互连接的寄存器传输级功能块组成的，HDL综合器则是用于逻辑综合工具。在把可综合的VHDL/Verilog HDL转化成硬件电路时，包含了三个过程： &lt;br /&gt;
（1）转化：综合工具读入电路系统的HDL描述，将其转化为各个功能单元连接的电路结构的门级网表。这是一个通用电路原理图形成的过程，不考虑实际器件的实现。 &lt;br /&gt;
（2）优化：根据设计者所施加的时序、面积等约束条件，针对实际实现的目标器件的结构转化的门级网表按一定的算法进行逻辑重组和优化，并使之满足各种约束条件。 &lt;br /&gt;
（3）映射：根据面积和时序的约束条件，综合工具从目标器件的工艺库中搜索恰当的单元来构成电路。  &lt;br /&gt;
HDL综合器由寄存器传输级（RTL）代码、调用模块的接口及用户设置的综合目标和约束条件共同参与完成。其中，调用模块的接口导入是由于RTL代码调用了一些外部模块，而这些外部模块不能被综合或无需综合，但逻辑综合器需要其接口的定义来检查逻辑并保留这些模块的接口。HDL综合器的输入文件一般是网表文件，如文件后缀.edf的EDIF格式文件，或是直接调用VHDL/Verilog HDL表达的标准格式网表文件，或对应FPGA器件厂商的网表文件。如Xilinx公司的XNF网表文件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;综合工具&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;厂商名称&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;综合器名称&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Xilinx&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;XST&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Synopsys&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;FPGA Compiler II&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Synopsys&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;FPGA express&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Synplicity&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Synplify&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Mentor Graphics&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Leonardo spectrum&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;       HDL综合器完成EDA设计流程中的一个独立设计步骤，它的调用方式一般有两种：一种是前台模式，在被调用时显示最常见的窗口界面；一种称为后台模式或控制台模式，在被调用时不出现图形界面，仅在后台运行。
### 仿真器
       仿真器有基于元件（逻辑门）的仿真器和HDL仿真器。基于元件的仿真器缺乏HDL仿真器的灵活性和通用性。
在EDA设计中，仿真的地位十分重要。行为模型的表达、电子系统的建模、逻辑电路的验证乃至门级系统的测试，每一步都离不开仿真器的模拟检测，各设计环节的仿真仍然是整个EDA工程中最耗时间的一个步骤，因此HDL仿真器的仿真速度、仿真的准确性和易用性成为衡量仿真器的重要指标。 &lt;br /&gt;
       HDL仿真器按对设计语言不同的处理方式分类，可以分为编译型和解释型仿真器。编译型仿真器的仿真速度较快，但需要预处理，因此不便即使修改仿真环境和条件；解释型仿真的速度一般，可以随时修改仿真环境和条件。  &lt;br /&gt;
       按照处理的硬件描述语言类型不同，HDL仿真器可分为VHDL仿真器、Verilog仿真器、Mixed HDL仿真器（同时处理Verilog HDL 与 VHDL）和其他HDL仿真器。 &lt;br /&gt;
       按照仿真时是否考虑硬件延时分类，HDL仿真器可分为功能仿真器和时序仿真器。根据输入和仿真文件的不同，可以由不同的仿真器完成，也可以由同一个仿真器完成。
- 功能仿真&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;       功能仿真是直接对HDL语言、原理图描述或其他描述形式描述的逻辑功能进行测试模拟，以了解其实现的功能是否满足原设计的要求。它是由设计输入的行为级或RTL级代码、测试数据参与的测试程序以及调用模块的行为仿真模型共同参与完成逻辑功能的验证。功能仿真没有延时信息，仿真过程不涉及任何具体器件的硬件特性，对于初步的逻辑功能检测非常方便。
- 时序仿真 
时序仿真是在选择了具体器件后，由适配器完成布局、布线并得到HDL网表和标准延时文件，以及FPGA基本单元仿真模型和测试程序，它们共同参与时序仿真。时序仿真包含了器件的硬件特性参数和内部连线时延的仿真，是接近真实器件运行特性仿真，因而仿真精度高。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;按照仿真电路级别的不同，HDL仿真器可以单独或综合完成以下各仿真步骤：&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(1) 系统级仿真&lt;br /&gt;
(2) 行为级仿真&lt;br /&gt;
(3) RTL级仿真&lt;br /&gt;
(4) 门级时序仿真&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;常用的仿真器&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;厂商名称&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;仿真器器名称&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Mentor Graphics&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Modelsim&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Aldec&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Active HDL&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Cadence&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;NC-VHDL&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Cadence&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;NC-Verilog&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Cadence&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Verilog-XL&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;SYNOPSYS&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;VCS&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;SYNOPSYS&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;VSS&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Xilinx&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Altera&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-5&quot;&gt;适配器（或称布局、布线器）&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;       适配即结构综合，它的任务是完成目标系统在器件上的布局和布线，通常是由可编程逻辑器件生产厂商提供的专门针对器件开发的软件来完成。这些软件可以单独运行或嵌入到厂商提供的EDA集成开发软件中，如Altera公司的EDA集成开发环境Quartus II 和 Xilinx 公司的ISE软件都含有嵌入的适配器。&lt;br /&gt;
       适配器利用综合器产生的网表文件、模块的综合模型以及用户设置的约束条件共同完成适配过程，最后输出的是符合各厂商定义的下载文件，用于下载到FPGA/CPLD器件中以最终实现设计。另外，适配器可以输出多种用途的文件：用于精确的时序仿真的延时文件；面向第三方EDA工具的输出文件，如HDL网表文件；适配技术报告文件等。
### 下载器（或称编程器）
       下载是在功能仿真与时序仿真正确的前提下，将综合后形成的下载文件下载到具体的FPGA芯片中，实现硬件设计，也叫芯片的编程/配置。下载软件一般由可编程逻辑器件厂商提供，或嵌入到EDA开发软件中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-6&quot;&gt;现代数字系统设计的发展趋势&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;电子设计最优化（EDO）&lt;/li&gt;
  &lt;li&gt;在线可重构技术&lt;/li&gt;
  &lt;li&gt;IRL技术主要特点体现
    &lt;ul&gt;
      &lt;li&gt;（1）器件结构的支持&lt;/li&gt;
      &lt;li&gt;（2）JAVA语言的使用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SOPC技术优势主要体现
    &lt;ul&gt;
      &lt;li&gt;（1）运用嵌入的微处理器软核和其他IP Core 资源。&lt;/li&gt;
      &lt;li&gt;（2）采用先进的EDA开发工具，如Xilinx公司的ISE以及EDK开发工具的出现，极大地提高了开发人员的工作效率。&lt;/li&gt;
      &lt;li&gt;（3）知识产权得到重视，越来越多的设计人员以IP Core设计及复用的方式对现在的IP Core加以充分利用，从而提高设计效率并缩短产品上市时间。&lt;/li&gt;
      &lt;li&gt;（4）通过SOPC技术，能够有机会融合MCU、DSP、和FPGA，兼顾他们各自的特点，这些特点顺应了未来嵌入式系统发展的趋势。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 06 Aug 2019 08:30:00 +0800</pubDate>
        <link>https://bbel.ink/2019/08/FPGA/</link>
        <guid isPermaLink="true">https://bbel.ink/2019/08/FPGA/</guid>
        
        <category>FPGA</category>
        
        
      </item>
    
      <item>
        <title>SQL</title>
        <description>&lt;!-- GFM-TOC --&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#一基础&quot;&gt;一、基础&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#二创建表&quot;&gt;二、创建表&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#三修改表&quot;&gt;三、修改表&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#四插入&quot;&gt;四、插入&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#五更新&quot;&gt;五、更新&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#六删除&quot;&gt;六、删除&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#七查询&quot;&gt;七、查询&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#八排序&quot;&gt;八、排序&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#九过滤&quot;&gt;九、过滤&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#十通配符&quot;&gt;十、通配符&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#十一计算字段&quot;&gt;十一、计算字段&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#十二函数&quot;&gt;十二、函数&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#十三分组&quot;&gt;十三、分组&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#十四子查询&quot;&gt;十四、子查询&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#十五连接&quot;&gt;十五、连接&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#十六组合查询&quot;&gt;十六、组合查询&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#十七视图&quot;&gt;十七、视图&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#十八存储过程&quot;&gt;十八、存储过程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#十九游标&quot;&gt;十九、游标&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#二十触发器&quot;&gt;二十、触发器&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#二十一事务管理&quot;&gt;二十一、事务管理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#二十二字符集&quot;&gt;二十二、字符集&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#二十三权限管理&quot;&gt;二十三、权限管理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#参考资料&quot;&gt;参考资料&lt;/a&gt;
&lt;!-- GFM-TOC --&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section&quot;&gt;一、基础&lt;/h1&gt;

&lt;p&gt;模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。&lt;/p&gt;

&lt;p&gt;主键的值不允许修改，也不允许复用（不能使用已经删除的主键值赋给新数据行的主键）。&lt;/p&gt;

&lt;p&gt;SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。&lt;/p&gt;

&lt;p&gt;SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。&lt;/p&gt;

&lt;p&gt;SQL 支持以下三种注释：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
# 注释
SELECT *
FROM mytable; -- 注释
/* 注释1
   注释2 */
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;数据库创建与使用：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
CREATE DATABASE test;
USE test;
&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;二、创建表&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
CREATE TABLE mytable (
  id INT NOT NULL AUTO_INCREMENT,
  col1 INT NOT NULL DEFAULT 1,
  col2 VARCHAR(45) NULL,
  col3 DATE NULL,
  PRIMARY KEY (`id`));
&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;三、修改表&lt;/h1&gt;

&lt;p&gt;添加列&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
ALTER TABLE mytable
ADD col CHAR(20);
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;删除列&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
ALTER TABLE mytable
DROP COLUMN col;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;删除表&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
DROP TABLE mytable;
&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-3&quot;&gt;四、插入&lt;/h1&gt;

&lt;p&gt;普通插入&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
INSERT INTO mytable(col1, col2)
VALUES(val1, val2);
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;插入检索出来的数据&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
INSERT INTO mytable1(col1, col2)
SELECT col1, col2
FROM mytable2;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;将一个表的内容插入到一个新表&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
CREATE TABLE newtable AS
SELECT * FROM mytable;
&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-4&quot;&gt;五、更新&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
UPDATE mytable
SET col = val
WHERE id = 1;
&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-5&quot;&gt;六、删除&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
DELETE FROM mytable
WHERE id = 1;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TRUNCATE TABLE&lt;/strong&gt;  可以清空表，也就是删除所有行。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
TRUNCATE TABLE mytable;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使用更新和删除操作时一定要用 WHERE 子句，不然会把整张表的数据都破坏。可以先用 SELECT 语句进行测试，防止错误删除。&lt;/p&gt;

&lt;h1 id=&quot;section-6&quot;&gt;七、查询&lt;/h1&gt;

&lt;h2 id=&quot;distinct&quot;&gt;DISTINCT&lt;/h2&gt;

&lt;p&gt;相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
SELECT DISTINCT col1, col2
FROM mytable;
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;limit&quot;&gt;LIMIT&lt;/h2&gt;

&lt;p&gt;限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。&lt;/p&gt;

&lt;p&gt;返回前 5 行：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
SELECT *
FROM mytable
LIMIT 5;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
SELECT *
FROM mytable
LIMIT 0, 5;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;返回第 3 \~ 5 行：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
SELECT *
FROM mytable
LIMIT 2, 3;
&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-7&quot;&gt;八、排序&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ASC&lt;/strong&gt; ：升序（默认）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;DESC&lt;/strong&gt; ：降序&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以按多个列进行排序，并且为每个列指定不同的排序方式：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
SELECT *
FROM mytable
ORDER BY col1 DESC, col2 ASC;
&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-8&quot;&gt;九、过滤&lt;/h1&gt;

&lt;p&gt;不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
SELECT *
FROM mytable
WHERE col IS NULL;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;下表显示了 WHERE 子句可用的操作符&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;操作符&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;=&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;等于&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&amp;lt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;小于&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&amp;gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;大于&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&amp;lt;&amp;gt; !=&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;不等于&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&amp;lt;= !&amp;gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;小于等于&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&amp;gt;= !&amp;lt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;大于等于&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;BETWEEN&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;在两个值之间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;IS NULL&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;为 NULL 值&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;应该注意到，NULL 与 0、空字符串都不同。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AND 和 OR&lt;/strong&gt;  用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IN&lt;/strong&gt;  操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOT&lt;/strong&gt;  操作符用于否定一个条件。&lt;/p&gt;

&lt;h1 id=&quot;section-9&quot;&gt;十、通配符&lt;/h1&gt;

&lt;p&gt;通配符也是用在过滤语句中，但它只能用于文本字段。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;%&lt;/strong&gt;  匹配 &amp;gt;=0 个任意字符；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;_&lt;/strong&gt;  匹配 ==1 个任意字符；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;[ ]&lt;/strong&gt;  可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用 Like 来进行通配符匹配。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
SELECT *
FROM mytable
WHERE col LIKE &#39;[^AB]%&#39;; -- 不以 A 和 B 开头的任意文本
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;不要滥用通配符，通配符位于开头处匹配会非常慢。&lt;/p&gt;

&lt;h1 id=&quot;section-10&quot;&gt;十一、计算字段&lt;/h1&gt;

&lt;p&gt;在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。&lt;/p&gt;

&lt;p&gt;计算字段通常需要使用  &lt;strong&gt;AS&lt;/strong&gt;  来取别名，否则输出的时候字段名为计算表达式。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
SELECT col1 * col2 AS alias
FROM mytable;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CONCAT()&lt;/strong&gt;  用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 &lt;strong&gt;TRIM()&lt;/strong&gt; 可以去除首尾空格。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
SELECT CONCAT(TRIM(col1), &#39;(&#39;, TRIM(col2), &#39;)&#39;) AS concat_col
FROM mytable;
&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-11&quot;&gt;十二、函数&lt;/h1&gt;

&lt;p&gt;各个 DBMS 的函数都是不相同的，因此不可移植，以下主要是 MySQL 的函数。&lt;/p&gt;

&lt;h2 id=&quot;section-12&quot;&gt;汇总&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;函 数&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;说 明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;AVG()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;返回某列的平均值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;COUNT()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;返回某列的行数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;MAX()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;返回某列的最大值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;MIN()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;返回某列的最小值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;SUM()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;返回某列值之和&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;AVG() 会忽略 NULL 行。&lt;/p&gt;

&lt;p&gt;使用 DISTINCT 可以让汇总函数值汇总不同的值。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
SELECT AVG(DISTINCT col1) AS avg_col
FROM mytable;
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-13&quot;&gt;文本处理&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;函数&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;LEFT()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;左边的字符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;RIGHT()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;右边的字符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;LOWER()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;转换为小写字符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;UPPER()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;转换为大写字符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;LTRIM()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;去除左边的空格&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;RTRIM()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;去除右边的空格&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;LENGTH()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;长度&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;SOUNDEX()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;转换为语音值&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其中， &lt;strong&gt;SOUNDEX()&lt;/strong&gt;  可以将一个字符串转换为描述其语音表示的字母数字模式。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
SELECT *
FROM mytable
WHERE SOUNDEX(col1) = SOUNDEX(&#39;apple&#39;)
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-14&quot;&gt;日期和时间处理&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;日期格式：YYYY-MM-DD&lt;/li&gt;
  &lt;li&gt;时间格式：HH:MM:SS&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;函 数&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;说 明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;AddDate()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;增加一个日期（天、周等）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;AddTime()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;增加一个时间（时、分等）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;CurDate()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;返回当前日期&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;CurTime()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;返回当前时间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Date()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;返回日期时间的日期部分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;DateDiff()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;计算两个日期之差&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Date_Add()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;高度灵活的日期运算函数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Date_Format()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;返回一个格式化的日期或时间串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Day()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;返回一个日期的天数部分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;DayOfWeek()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;对于一个日期，返回对应的星期几&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Hour()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;返回一个时间的小时部分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Minute()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;返回一个时间的分钟部分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Month()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;返回一个日期的月份部分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Now()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;返回当前日期和时间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Second()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;返回一个时间的秒部分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Time()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;返回一个日期时间的时间部分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Year()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;返回一个日期的年份部分&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
mysql&amp;gt; SELECT NOW();
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
2018-4-14 20:25:11
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-15&quot;&gt;数值处理&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;函数&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;SIN()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;正弦&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;COS()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;余弦&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;TAN()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;正切&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ABS()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;绝对值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;SQRT()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;平方根&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;MOD()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;余数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;EXP()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;指数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;PI()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;圆周率&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;RAND()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;随机数&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;section-16&quot;&gt;十三、分组&lt;/h1&gt;

&lt;p&gt;分组就是把具有相同的数据值的行放在同一组中。&lt;/p&gt;

&lt;p&gt;可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。&lt;/p&gt;

&lt;p&gt;指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
SELECT col, COUNT(*) AS num
FROM mytable
GROUP BY col;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;GROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
SELECT col, COUNT(*) AS num
FROM mytable
GROUP BY col
ORDER BY num;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
SELECT col, COUNT(*) AS num
FROM mytable
WHERE col &amp;gt; 2
GROUP BY col
HAVING num &amp;gt;= 2;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;分组规定：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；&lt;/li&gt;
  &lt;li&gt;除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；&lt;/li&gt;
  &lt;li&gt;NULL 的行会单独分为一组；&lt;/li&gt;
  &lt;li&gt;大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section-17&quot;&gt;十四、子查询&lt;/h1&gt;

&lt;p&gt;子查询中只能返回一个字段的数据。&lt;/p&gt;

&lt;p&gt;可以将子查询的结果作为 WHRER 语句的过滤条件：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
SELECT *
FROM mytable1
WHERE col1 IN (SELECT col2
               FROM mytable2);
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
SELECT cust_name, (SELECT COUNT(*)
                   FROM Orders
                   WHERE Orders.cust_id = Customers.cust_id)
                   AS orders_num
FROM Customers
ORDER BY cust_name;
&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-18&quot;&gt;十五、连接&lt;/h1&gt;

&lt;p&gt;连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。&lt;/p&gt;

&lt;p&gt;连接可以替换子查询，并且比子查询的效率一般会更快。&lt;/p&gt;

&lt;p&gt;可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。&lt;/p&gt;

&lt;h2 id=&quot;section-19&quot;&gt;内连接&lt;/h2&gt;

&lt;p&gt;内连接又称等值连接，使用 INNER JOIN 关键字。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
SELECT A.value, B.value
FROM tablea AS A INNER JOIN tableb AS B
ON A.key = B.key;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
SELECT A.value, B.value
FROM tablea AS A, tableb AS B
WHERE A.key = B.key;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在没有条件语句的情况下返回笛卡尔积。&lt;/p&gt;

&lt;h2 id=&quot;section-20&quot;&gt;自连接&lt;/h2&gt;

&lt;p&gt;自连接可以看成内连接的一种，只是连接的表是自身而已。&lt;/p&gt;

&lt;p&gt;一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。&lt;/p&gt;

&lt;p&gt;子查询版本&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
SELECT name
FROM employee
WHERE department = (
      SELECT department
      FROM employee
      WHERE name = &quot;Jim&quot;);
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;自连接版本&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
SELECT e1.name
FROM employee AS e1 INNER JOIN employee AS e2
ON e1.department = e2.department
      AND e2.name = &quot;Jim&quot;;
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-21&quot;&gt;自然连接&lt;/h2&gt;

&lt;p&gt;自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。&lt;/p&gt;

&lt;p&gt;内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
SELECT A.value, B.value
FROM tablea AS A NATURAL JOIN tableb AS B;
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-22&quot;&gt;外连接&lt;/h2&gt;

&lt;p&gt;外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。&lt;/p&gt;

&lt;p&gt;检索所有顾客的订单信息，包括还没有订单信息的顾客。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
SELECT Customers.cust_id, Orders.order_num
FROM Customers LEFT OUTER JOIN Orders
ON Customers.cust_id = Orders.cust_id;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;customers 表：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;cust_id&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;cust_name&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;a&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;b&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;c&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;orders 表：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;order_id&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;cust_id&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;结果：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;cust_id&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;cust_name&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;order_id&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;a&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;a&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;c&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;c&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;b&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Null&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;section-23&quot;&gt;十六、组合查询&lt;/h1&gt;

&lt;p&gt;使用  &lt;strong&gt;UNION&lt;/strong&gt;  来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。&lt;/p&gt;

&lt;p&gt;每个查询必须包含相同的列、表达式和聚集函数。&lt;/p&gt;

&lt;p&gt;默认会去除相同行，如果需要保留相同行，使用 UNION ALL。&lt;/p&gt;

&lt;p&gt;只能包含一个 ORDER BY 子句，并且必须位于语句的最后。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
SELECT col
FROM mytable
WHERE col = 1
UNION
SELECT col
FROM mytable
WHERE col =2;
&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-24&quot;&gt;十七、视图&lt;/h1&gt;

&lt;p&gt;视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。&lt;/p&gt;

&lt;p&gt;对视图的操作和对普通表的操作一样。&lt;/p&gt;

&lt;p&gt;视图具有如下好处：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;简化复杂的 SQL 操作，比如复杂的连接；&lt;/li&gt;
  &lt;li&gt;只使用实际表的一部分数据；&lt;/li&gt;
  &lt;li&gt;通过只给用户访问视图的权限，保证数据的安全性；&lt;/li&gt;
  &lt;li&gt;更改数据格式和表示。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
CREATE VIEW myview AS
SELECT Concat(col1, col2) AS concat_col, col3*col4 AS compute_col
FROM mytable
WHERE col5 = val;
&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-25&quot;&gt;十八、存储过程&lt;/h1&gt;

&lt;p&gt;存储过程可以看成是对一系列 SQL 操作的批处理。&lt;/p&gt;

&lt;p&gt;使用存储过程的好处：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;代码封装，保证了一定的安全性；&lt;/li&gt;
  &lt;li&gt;代码复用；&lt;/li&gt;
  &lt;li&gt;由于是预先编译，因此具有很高的性能。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。&lt;/p&gt;

&lt;p&gt;包含 in、out 和 inout 三种参数。&lt;/p&gt;

&lt;p&gt;给变量赋值都需要用 select into 语句。&lt;/p&gt;

&lt;p&gt;每次只能给一个变量赋值，不支持集合的操作。&lt;/p&gt;

&lt;p&gt;```sql
delimiter //&lt;/p&gt;

&lt;p&gt;create procedure myprocedure( out ret int )
    begin
        declare y int;
        select sum(col1)
        from mytable
        into y;
        select y*y into ret;
    end //&lt;/p&gt;

&lt;p&gt;delimiter ;
```&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
call myprocedure(@ret);
select @ret;
&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-26&quot;&gt;十九、游标&lt;/h1&gt;

&lt;p&gt;在存储过程中使用游标可以对一个结果集进行移动遍历。&lt;/p&gt;

&lt;p&gt;游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。&lt;/p&gt;

&lt;p&gt;使用游标的四个步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;声明游标，这个过程没有实际检索出数据；&lt;/li&gt;
  &lt;li&gt;打开游标；&lt;/li&gt;
  &lt;li&gt;取出数据；&lt;/li&gt;
  &lt;li&gt;关闭游标；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;```sql
delimiter //
create procedure myprocedure(out ret int)
    begin
        declare done boolean default 0;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    declare mycursor cursor for
    select col1 from mytable;
    # 定义了一个 continue handler，当 sqlstate &#39;02000&#39; 这个条件出现时，会执行 set done = 1
    declare continue handler for sqlstate &#39;02000&#39; set done = 1;

    open mycursor;

    repeat
        fetch mycursor into ret;
        select ret;
    until done end repeat;

    close mycursor;
end //  delimiter ; ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;section-27&quot;&gt;二十、触发器&lt;/h1&gt;

&lt;p&gt;触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDATE。&lt;/p&gt;

&lt;p&gt;触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化，AFTER 用于审计跟踪，将修改记录到另外一张表中。&lt;/p&gt;

&lt;p&gt;INSERT 触发器包含一个名为 NEW 的虚拟表。&lt;/p&gt;

&lt;p&gt;```sql
CREATE TRIGGER mytrigger AFTER INSERT ON mytable
FOR EACH ROW SELECT NEW.col into @result;&lt;/p&gt;

&lt;p&gt;SELECT @result; – 获取结果
```&lt;/p&gt;

&lt;p&gt;DELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。&lt;/p&gt;

&lt;p&gt;UPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改的，而 OLD 是只读的。&lt;/p&gt;

&lt;p&gt;MySQL 不允许在触发器中使用 CALL 语句，也就是不能调用存储过程。&lt;/p&gt;

&lt;h1 id=&quot;section-28&quot;&gt;二十一、事务管理&lt;/h1&gt;

&lt;p&gt;基本术语：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;事务（transaction）指一组 SQL 语句；&lt;/li&gt;
  &lt;li&gt;回退（rollback）指撤销指定 SQL 语句的过程；&lt;/li&gt;
  &lt;li&gt;提交（commit）指将未存储的 SQL 语句结果写入数据库表；&lt;/li&gt;
  &lt;li&gt;保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。&lt;/p&gt;

&lt;p&gt;MySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。&lt;/p&gt;

&lt;p&gt;通过设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的。&lt;/p&gt;

&lt;p&gt;如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
START TRANSACTION
// ...
SAVEPOINT delete1
// ...
ROLLBACK TO delete1
// ...
COMMIT
&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-29&quot;&gt;二十二、字符集&lt;/h1&gt;

&lt;p&gt;基本术语：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;字符集为字母和符号的集合；&lt;/li&gt;
  &lt;li&gt;编码为某个字符集成员的内部表示；&lt;/li&gt;
  &lt;li&gt;校对字符指定如何比较，主要用于排序和分组。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除了给表指定字符集和校对外，也可以给列指定：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
CREATE TABLE mytable
(col VARCHAR(10) CHARACTER SET latin COLLATE latin1_general_ci )
DEFAULT CHARACTER SET hebrew COLLATE hebrew_general_ci;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可以在排序、分组时指定校对：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
SELECT *
FROM mytable
ORDER BY col COLLATE latin1_general_ci;
&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-30&quot;&gt;二十三、权限管理&lt;/h1&gt;

&lt;p&gt;MySQL 的账户信息保存在 mysql 这个数据库中。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
USE mysql;
SELECT user FROM user;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;创建账户&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;新创建的账户没有任何权限。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
CREATE USER myuser IDENTIFIED BY &#39;mypassword&#39;;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;修改账户名&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
RENAME myuser TO newuser;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;删除账户&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
DROP USER myuser;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;查看权限&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
SHOW GRANTS FOR myuser;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;授予权限&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;账户用 username@host 的形式定义，username@% 使用的是默认主机名。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
GRANT SELECT, INSERT ON mydatabase.* TO myuser;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;删除权限&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;GRANT 和 REVOKE 可在几个层次上控制访问权限：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;整个服务器，使用 GRANT ALL 和 REVOKE ALL；&lt;/li&gt;
  &lt;li&gt;整个数据库，使用 ON database.*；&lt;/li&gt;
  &lt;li&gt;特定的表，使用 ON database.table；&lt;/li&gt;
  &lt;li&gt;特定的列；&lt;/li&gt;
  &lt;li&gt;特定的存储过程。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
REVOKE SELECT, INSERT ON mydatabase.* FROM myuser;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;更改密码&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;必须使用 Password() 函数&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sql
SET PASSWROD FOR myuser = Password(&#39;new_password&#39;);
&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-31&quot;&gt;参考资料&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;BenForta. SQL 必知必会 [M]. 人民邮电出版社, 2013.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 06 Aug 2019 08:30:00 +0800</pubDate>
        <link>https://bbel.ink/2019/08/SQL/</link>
        <guid isPermaLink="true">https://bbel.ink/2019/08/SQL/</guid>
        
        <category>SQL</category>
        
        
      </item>
    
      <item>
        <title>代码风格规范</title>
        <description>&lt;!-- GFM-TOC --&gt;
&lt;!-- GFM-TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/twitter/commons/blob/master/src/java/com/twitter/common/styleguide.md&quot;&gt;Twitter Java Style Guide&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://google.github.io/styleguide/javaguide.html&quot;&gt;Google Java Style Guide&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/alibaba/p3c/blob/master/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E8%AF%A6%E5%B0%BD%E7%89%88%EF%BC%89.pdf&quot;&gt;阿里巴巴Java开发手册&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 06 Aug 2019 08:30:00 +0800</pubDate>
        <link>https://bbel.ink/2019/08/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83/</link>
        <guid isPermaLink="true">https://bbel.ink/2019/08/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83/</guid>
        
        <category>My</category>
        
        
      </item>
    
      <item>
        <title>但行好事，莫问前程</title>
        <description>&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    2019 年已经过去二分之一了从来到中江也已经3个月了，想想时间也是过的非常长的快，来了之后也一直没有在写一些什么，工作强度也不如成都来的重但就是看书和记录的习惯慢慢的退化了
这周末突然想起来我还是应该记录点什么（其实其他周末也有想起）先来说说这里的感受吧，八线小城市空气好，安静，生活压力明显小很多，也刚好平复下混乱的心，
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sat, 23 Feb 2019 08:30:00 +0800</pubDate>
        <link>https://bbel.ink/2019/02/%E4%BD%86%E8%A1%8C%E5%A5%BD%E4%BA%8B-%E8%8E%AB%E9%97%AE%E5%89%8D%E7%A8%8B/</link>
        <guid isPermaLink="true">https://bbel.ink/2019/02/%E4%BD%86%E8%A1%8C%E5%A5%BD%E4%BA%8B-%E8%8E%AB%E9%97%AE%E5%89%8D%E7%A8%8B/</guid>
        
        <category>my 但行好事，莫问前程</category>
        
        
      </item>
    
      <item>
        <title>ubuntu18.04下Mysql5.7</title>
        <description>&lt;p&gt;mysql出现ERROR1698(28000):Access denied for user root@localhost错误解决方法&lt;/p&gt;

&lt;p&gt;我的操作系统是ubuntu18.04，以下是我的mysql版本：&lt;/p&gt;

&lt;p&gt;安装完成后，登录mysql的时候就出现了如下错误：&lt;/p&gt;

&lt;p&gt;因为安装的过程中没让设置密码，可能密码为空，但无论如何都进不去mysql。&lt;/p&gt;

&lt;p&gt;那么该怎么做呢，接下来就将这个解决方法总结记录一下。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;step1：在ubuntu的terminal（也即终端）上输入sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf,进入到这个配置文件，然后在这个配置文件中的[mysqld]这一块中加入skip-grant-tables这句话。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;复制代码
&lt;code class=&quot;highlighter-rouge&quot;&gt;
 1 [mysqld]
 2 #
 3 # * Basic Settings
 4 #
 5 user            　 = mysql
 6 pid-file        　 = /var/run/mysqld/mysqld.pid
 7 socket        　　 = /var/run/mysqld/mysqld.sock
 8 port            　 = 3306
 9 basedir        　　= /usr
10 datadir       　　 = /var/lib/mysql
11 tmpdir       　　　= /tmp
12 lc-messages-dir   = /usr/share/mysql
13 skip-external-locking
14 character-set-server=utf8
15 collation-server=utf8_general_ci
16 skip-grant-tables　　　　&amp;lt;-- add here
&lt;/code&gt;
复制代码&lt;/p&gt;

&lt;p&gt;作用：就是让你可以不用密码登录进去mysql。&lt;/p&gt;

&lt;p&gt;保存:wq，退出。输入：service mysql restart，重新启动mysql。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;step2：在终端上输入mysql -u root -p，遇见输入密码的提示直接回车即可,进入mysql后，分别执行下面三句话： ``` 1 use mysql;   然后敲回车 2 update user set authentication_string=password(&quot;你的密码&quot;) where user=&quot;root&quot;;  然后敲回车 3 flush privileges;  然后敲回车 ``` 结果如下图：
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后输入quit，退出mysql。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;step3：重新进入到mysqld.cnf文件中去把刚开始加的skip-grant-tables这条语句给注释掉。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;复制代码
&lt;code class=&quot;highlighter-rouge&quot;&gt;
 1 [mysqld]
 2 #
 3 # * Basic Settings
 4 #
 5 user            　 = mysql
 6 pid-file        　 = /var/run/mysqld/mysqld.pid
 7 socket        　　 = /var/run/mysqld/mysqld.sock
 8 port            　 = 3306
 9 basedir        　　= /usr
10 datadir       　　 = /var/lib/mysql
11 tmpdir       　　　= /tmp
12 lc-messages-dir   = /usr/share/mysql
13 skip-external-locking
14 character-set-server=utf8
15 collation-server=utf8_general_ci
16 # skip-grant-tables　　　　&amp;lt;-- add # here
&lt;/code&gt;
复制代码&lt;/p&gt;

&lt;p&gt;再返回终端输入mysql -u root -p，应该就可以进入数据库了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;step4：如果此时还是报出错误，那么就需要返回step3中，把注释掉的那条语句重新生效（就是删除#符号），重新进入mysql中，先选择一个数据库（use mysql;）,然后输入select user,plugin from user;，看下图：
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从图中可以看到在执行了select user,plugin from user;后，错误原因是因为plugin root的字段是auth_socket，那我们改掉它为下面的mysql_native_password就行了。输入：
&lt;code class=&quot;highlighter-rouge&quot;&gt;
1 update user set authentication_string=password(&quot;ln122920&quot;),plugin=&#39;mysql_native_password&#39; where user=&#39;root&#39;;
&lt;/code&gt;
然后回车执行以下，再输入select user,plugin from user;回车，我们能看到root用户的字段改成功了。&lt;/p&gt;

&lt;p&gt;最后quit退出。返回执行step3。&lt;/p&gt;

&lt;p&gt;那么这个问题就完全解决了。&lt;/p&gt;

&lt;p&gt;参考链接：https://www.cnblogs.com/cpl9412290130/p/9583868.html&lt;/p&gt;
</description>
        <pubDate>Sat, 23 Feb 2019 08:30:00 +0800</pubDate>
        <link>https://bbel.ink/2019/02/ubuntu18.04%E4%B8%8BMysql/</link>
        <guid isPermaLink="true">https://bbel.ink/2019/02/ubuntu18.04%E4%B8%8BMysql/</guid>
        
        <category>ubuntu18.04</category>
        
        <category>Mysql5.7</category>
        
        
      </item>
    
      <item>
        <title>设计模式</title>
        <description>&lt;!-- GFM-TOC --&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#一概述&quot;&gt;一、概述&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#二创建型&quot;&gt;二、创建型&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#1-单例singleton&quot;&gt;1. 单例（Singleton）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#2-简单工厂simple-factory&quot;&gt;2. 简单工厂（Simple Factory）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#3-工厂方法factory-method&quot;&gt;3. 工厂方法（Factory Method）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#4-抽象工厂abstract-factory&quot;&gt;4. 抽象工厂（Abstract Factory）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#5-生成器builder&quot;&gt;5. 生成器（Builder）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#6-原型模式prototype&quot;&gt;6. 原型模式（Prototype）&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#三行为型&quot;&gt;三、行为型&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#1-责任链chain-of-responsibility&quot;&gt;1. 责任链（Chain Of Responsibility）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#2-命令command&quot;&gt;2. 命令（Command）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#3-解释器interpreter&quot;&gt;3. 解释器（Interpreter）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#4-迭代器iterator&quot;&gt;4. 迭代器（Iterator）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#5-中介者mediator&quot;&gt;5. 中介者（Mediator）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#6-备忘录memento&quot;&gt;6. 备忘录（Memento）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#7-观察者observer&quot;&gt;7. 观察者（Observer）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#8-状态state&quot;&gt;8. 状态（State）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#9-策略strategy&quot;&gt;9. 策略（Strategy）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#10-模板方法template-method&quot;&gt;10. 模板方法（Template Method）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#11-访问者visitor&quot;&gt;11. 访问者（Visitor）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#12-空对象null&quot;&gt;12. 空对象（Null）&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#四结构型&quot;&gt;四、结构型&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#1-适配器adapter&quot;&gt;1. 适配器（Adapter）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#2-桥接bridge&quot;&gt;2. 桥接（Bridge）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#3-组合composite&quot;&gt;3. 组合（Composite）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#4-装饰decorator&quot;&gt;4. 装饰（Decorator）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#5-外观facade&quot;&gt;5. 外观（Facade）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#6-享元flyweight&quot;&gt;6. 享元（Flyweight）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#7-代理proxy&quot;&gt;7. 代理（Proxy）&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#参考资料&quot;&gt;参考资料&lt;/a&gt;
&lt;!-- GFM-TOC --&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section&quot;&gt;一、概述&lt;/h1&gt;

&lt;p&gt;设计模式是解决问题的方案，学习现有的设计模式可以做到经验复用。&lt;/p&gt;

&lt;p&gt;拥有设计模式词汇，在沟通时就能用更少的词汇来讨论，并且不需要了解底层细节。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/CyC2018/Design-Pattern-Java&quot;&gt;源码以及 UML 图&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;二、创建型&lt;/h1&gt;

&lt;h2 id=&quot;singleton&quot;&gt;1. 单例（Singleton）&lt;/h2&gt;

&lt;h3 id=&quot;intent&quot;&gt;Intent&lt;/h3&gt;

&lt;p&gt;确保一个类只有一个实例，并提供该实例的全局访问点。&lt;/p&gt;

&lt;h3 id=&quot;class-diagram&quot;&gt;Class Diagram&lt;/h3&gt;

&lt;p&gt;使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。&lt;/p&gt;

&lt;p&gt;私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/562f2844-d77c-40e0-887a-28a7128abd42.png&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;implementation&quot;&gt;Implementation&lt;/h3&gt;

&lt;h4 id=&quot;section-2&quot;&gt;Ⅰ 懒汉式-线程不安全&lt;/h4&gt;

&lt;p&gt;以下实现中，私有静态变量 uniqueInstance 被延迟实例化，这样做的好处是，如果没有用到该类，那么就不会实例化 uniqueInstance，从而节约资源。&lt;/p&gt;

&lt;p&gt;这个实现在多线程环境下是不安全的，如果多个线程能够同时进入 &lt;code class=&quot;highlighter-rouge&quot;&gt;if (uniqueInstance == null)&lt;/code&gt; ，并且此时 uniqueInstance 为 null，那么会有多个线程执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;uniqueInstance = new Singleton();&lt;/code&gt; 语句，这将导致实例化多次 uniqueInstance。&lt;/p&gt;

&lt;p&gt;```java
public class Singleton {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static Singleton uniqueInstance;

private Singleton() {
}

public static Singleton getUniqueInstance() {
    if (uniqueInstance == null) {
        uniqueInstance = new Singleton();
    }
    return uniqueInstance;
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-3&quot;&gt;Ⅱ 饿汉式-线程安全&lt;/h4&gt;

&lt;p&gt;线程不安全问题主要是由于 uniqueInstance 被实例化多次，采取直接实例化 uniqueInstance 的方式就不会产生线程不安全问题。&lt;/p&gt;

&lt;p&gt;但是直接实例化的方式也丢失了延迟实例化带来的节约资源的好处。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
private static Singleton uniqueInstance = new Singleton();
&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;Ⅲ 懒汉式-线程安全&lt;/h4&gt;

&lt;p&gt;只需要对 getUniqueInstance() 方法加锁，那么在一个时间点只能有一个线程能够进入该方法，从而避免了实例化多次 uniqueInstance。&lt;/p&gt;

&lt;p&gt;但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，即使 uniqueInstance 已经被实例化了。这会让线程阻塞时间过长，因此该方法有性能问题，不推荐使用。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public static synchronized Singleton getUniqueInstance() {
    if (uniqueInstance == null) {
        uniqueInstance = new Singleton();
    }
    return uniqueInstance;
}
&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;Ⅳ 双重校验锁-线程安全&lt;/h4&gt;

&lt;p&gt;uniqueInstance 只需要被实例化一次，之后就可以直接使用了。加锁操作只需要对实例化那部分的代码进行，只有当 uniqueInstance 没有被实例化时，才需要进行加锁。&lt;/p&gt;

&lt;p&gt;双重校验锁先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。&lt;/p&gt;

&lt;p&gt;```java
public class Singleton {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private volatile static Singleton uniqueInstance;

private Singleton() {
}

public static Singleton getUniqueInstance() {
    if (uniqueInstance == null) {
        synchronized (Singleton.class) {
            if (uniqueInstance == null) {
                uniqueInstance = new Singleton();
            }
        }
    }
    return uniqueInstance;
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;考虑下面的实现，也就是只使用了一个 if 语句。在 uniqueInstance == null 的情况下，如果两个线程都执行了 if 语句，那么两个线程都会进入 if 语句块内。虽然在 if 语句块内有加锁操作，但是两个线程都会执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;uniqueInstance = new Singleton();&lt;/code&gt; 这条语句，只是先后的问题，那么就会进行两次实例化。因此必须使用双重校验锁，也就是需要使用两个 if 语句。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
if (uniqueInstance == null) {
    synchronized (Singleton.class) {
        uniqueInstance = new Singleton();
    }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;uniqueInstance 采用 volatile 关键字修饰也是很有必要的， &lt;code class=&quot;highlighter-rouge&quot;&gt;uniqueInstance = new Singleton();&lt;/code&gt; 这段代码其实是分为三步执行：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;为 uniqueInstance 分配内存空间&lt;/li&gt;
  &lt;li&gt;初始化 uniqueInstance&lt;/li&gt;
  &lt;li&gt;将 uniqueInstance 指向分配的内存地址&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&amp;gt;3&amp;gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T&lt;sub&gt;1&lt;/sub&gt; 执行了 1 和 3，此时 T&lt;sub&gt;2&lt;/sub&gt; 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。&lt;/p&gt;

&lt;p&gt;使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;Ⅴ 静态内部类实现&lt;/h4&gt;

&lt;p&gt;当 Singleton 类加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;getUniqueInstance()&lt;/code&gt; 方法从而触发 &lt;code class=&quot;highlighter-rouge&quot;&gt;SingletonHolder.INSTANCE&lt;/code&gt; 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。&lt;/p&gt;

&lt;p&gt;这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。&lt;/p&gt;

&lt;p&gt;```java
public class Singleton {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private Singleton() {
}

private static class SingletonHolder {
    private static final Singleton INSTANCE = new Singleton();
}

public static Singleton getUniqueInstance() {
    return SingletonHolder.INSTANCE;
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-7&quot;&gt;Ⅵ 枚举实现&lt;/h4&gt;

&lt;p&gt;```java
public enum Singleton {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;INSTANCE;

private String objName;


public String getObjName() {
    return objName;
}


public void setObjName(String objName) {
    this.objName = objName;
}


public static void main(String[] args) {

    // 单例测试
    Singleton firstSingleton = Singleton.INSTANCE;
    firstSingleton.setObjName(&quot;firstName&quot;);
    System.out.println(firstSingleton.getObjName());
    Singleton secondSingleton = Singleton.INSTANCE;
    secondSingleton.setObjName(&quot;secondName&quot;);
    System.out.println(firstSingleton.getObjName());
    System.out.println(secondSingleton.getObjName());

    // 反射获取实例测试
    try {
        Singleton[] enumConstants = Singleton.class.getEnumConstants();
        for (Singleton enumConstant : enumConstants) {
            System.out.println(enumConstant.getObjName());
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;html
firstName
secondName
secondName
secondName
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;该实现在多次序列化再进行反序列化之后，不会得到多个实例。而其它实现需要使用 transient 修饰所有字段，并且实现序列化和反序列化的方法。&lt;/p&gt;

&lt;p&gt;该实现可以防止反射攻击。在其它实现中，通过 setAccessible() 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象，如果要防止这种攻击，需要在构造函数中添加防止多次实例化的代码。该实现是由 JVM 保证只会实例化一次，因此不会出现上述的反射攻击。&lt;/p&gt;

&lt;h3 id=&quot;examples&quot;&gt;Examples&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Logger Classes&lt;/li&gt;
  &lt;li&gt;Configuration Classes&lt;/li&gt;
  &lt;li&gt;Accesing resources in shared mode&lt;/li&gt;
  &lt;li&gt;Factories implemented as Singletons&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;jdk&quot;&gt;JDK&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/Runtime.html#getRuntime%28%29&quot;&gt;java.lang.Runtime#getRuntime()&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/awt/Desktop.html#getDesktop--&quot;&gt;java.awt.Desktop#getDesktop()&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/System.html#getSecurityManager--&quot;&gt;java.lang.System#getSecurityManager()&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;simple-factory&quot;&gt;2. 简单工厂（Simple Factory）&lt;/h2&gt;

&lt;h3 id=&quot;intent-1&quot;&gt;Intent&lt;/h3&gt;

&lt;p&gt;在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。&lt;/p&gt;

&lt;h3 id=&quot;class-diagram-1&quot;&gt;Class Diagram&lt;/h3&gt;

&lt;p&gt;简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。&lt;/p&gt;

&lt;p&gt;这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/c79da808-0f28-4a36-bc04-33ccc5b83c13.png&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;implementation-1&quot;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public interface Product {
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public class ConcreteProduct implements Product {
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public class ConcreteProduct1 implements Product {
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public class ConcreteProduct2 implements Product {
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以下的 Client 类包含了实例化的代码，这是一种错误的实现。如果在客户类中存在这种实例化代码，就需要考虑将代码放到简单工厂中。&lt;/p&gt;

&lt;p&gt;```java
public class Client {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main(String[] args) {
    int type = 1;
    Product product;
    if (type == 1) {
        product = new ConcreteProduct1();
    } else if (type == 2) {
        product = new ConcreteProduct2();
    } else {
        product = new ConcreteProduct();
    }
    // do something with the product
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以下的 SimpleFactory 是简单工厂实现，它被所有需要进行实例化的客户类调用。&lt;/p&gt;

&lt;p&gt;```java
public class SimpleFactory {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public Product createProduct(int type) {
    if (type == 1) {
        return new ConcreteProduct1();
    } else if (type == 2) {
        return new ConcreteProduct2();
    }
    return new ConcreteProduct();
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class Client {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main(String[] args) {
    SimpleFactory simpleFactory = new SimpleFactory();
    Product product = simpleFactory.createProduct(1);
    // do something with the product
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;factory-method&quot;&gt;3. 工厂方法（Factory Method）&lt;/h2&gt;

&lt;h3 id=&quot;intent-2&quot;&gt;Intent&lt;/h3&gt;

&lt;p&gt;定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。&lt;/p&gt;

&lt;h3 id=&quot;class-diagram-2&quot;&gt;Class Diagram&lt;/h3&gt;

&lt;p&gt;在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。&lt;/p&gt;

&lt;p&gt;下图中，Factory 有一个 doSomething() 方法，这个方法需要用到一个产品对象，这个产品对象由 factoryMethod() 方法创建。该方法是抽象的，需要由子类去实现。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/1818e141-8700-4026-99f7-900a545875f5.png&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;implementation-2&quot;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public abstract class Factory {
    abstract public Product factoryMethod();
    public void doSomething() {
        Product product = factoryMethod();
        // do something with the product
    }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public class ConcreteFactory extends Factory {
    public Product factoryMethod() {
        return new ConcreteProduct();
    }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public class ConcreteFactory1 extends Factory {
    public Product factoryMethod() {
        return new ConcreteProduct1();
    }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public class ConcreteFactory2 extends Factory {
    public Product factoryMethod() {
        return new ConcreteProduct2();
    }
}
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;jdk-1&quot;&gt;JDK&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/Calendar.html#getInstance--&quot;&gt;java.util.Calendar&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/ResourceBundle.html#getBundle-java.lang.String-&quot;&gt;java.util.ResourceBundle&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/text/NumberFormat.html#getInstance--&quot;&gt;java.text.NumberFormat&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html#forName-java.lang.String-&quot;&gt;java.nio.charset.Charset&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/URLStreamHandlerFactory.html#createURLStreamHandler-java.lang.String-&quot;&gt;java.net.URLStreamHandlerFactory&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/EnumSet.html#of-E-&quot;&gt;java.util.EnumSet&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/JAXBContext.html#createMarshaller--&quot;&gt;javax.xml.bind.JAXBContext&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;abstract-factory&quot;&gt;4. 抽象工厂（Abstract Factory）&lt;/h2&gt;

&lt;h3 id=&quot;intent-3&quot;&gt;Intent&lt;/h3&gt;

&lt;p&gt;提供一个接口，用于创建  &lt;strong&gt;相关的对象家族&lt;/strong&gt; 。&lt;/p&gt;

&lt;h3 id=&quot;class-diagram-3&quot;&gt;Class Diagram&lt;/h3&gt;

&lt;p&gt;抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。&lt;/p&gt;

&lt;p&gt;抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。&lt;/p&gt;

&lt;p&gt;至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。&lt;/p&gt;

&lt;p&gt;从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/8668a3e1-c9c7-4fcb-98b2-a96a5d841579.png&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;implementation-3&quot;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public class AbstractProductA {
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public class AbstractProductB {
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public class ProductA1 extends AbstractProductA {
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public class ProductA2 extends AbstractProductA {
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public class ProductB1 extends AbstractProductB {
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public class ProductB2 extends AbstractProductB {
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public abstract class AbstractFactory {
    abstract AbstractProductA createProductA();
    abstract AbstractProductB createProductB();
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;```java
public class ConcreteFactory1 extends AbstractFactory {
    AbstractProductA createProductA() {
        return new ProductA1();
    }&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AbstractProductB createProductB() {
    return new ProductB1();
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class ConcreteFactory2 extends AbstractFactory {
    AbstractProductA createProductA() {
        return new ProductA2();
    }&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AbstractProductB createProductB() {
    return new ProductB2();
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public class Client {
    public static void main(String[] args) {
        AbstractFactory abstractFactory = new ConcreteFactory1();
        AbstractProductA productA = abstractFactory.createProductA();
        AbstractProductB productB = abstractFactory.createProductB();
        // do something with productA and productB
    }
}
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;jdk-2&quot;&gt;JDK&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/javax/xml/parsers/DocumentBuilderFactory.html&quot;&gt;javax.xml.parsers.DocumentBuilderFactory&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/javax/xml/transform/TransformerFactory.html#newInstance--&quot;&gt;javax.xml.transform.TransformerFactory&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/javax/xml/xpath/XPathFactory.html#newInstance--&quot;&gt;javax.xml.xpath.XPathFactory&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;builder&quot;&gt;5. 生成器（Builder）&lt;/h2&gt;

&lt;h3 id=&quot;intent-4&quot;&gt;Intent&lt;/h3&gt;

&lt;p&gt;封装一个对象的构造过程，并允许按步骤构造。&lt;/p&gt;

&lt;h3 id=&quot;class-diagram-4&quot;&gt;Class Diagram&lt;/h3&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/13b0940e-d1d7-4b17-af4f-b70cb0a75e08.png&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;implementation-4&quot;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;以下是一个简易的 StringBuilder 实现，参考了 JDK 1.8 源码。&lt;/p&gt;

&lt;p&gt;```java
public class AbstractStringBuilder {
    protected char[] value;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected int count;

public AbstractStringBuilder(int capacity) {
    count = 0;
    value = new char[capacity];
}

public AbstractStringBuilder append(char c) {
    ensureCapacityInternal(count + 1);
    value[count++] = c;
    return this;
}

private void ensureCapacityInternal(int minimumCapacity) {
    // overflow-conscious code
    if (minimumCapacity - value.length &amp;gt; 0)
        expandCapacity(minimumCapacity);
}

void expandCapacity(int minimumCapacity) {
    int newCapacity = value.length * 2 + 2;
    if (newCapacity - minimumCapacity &amp;lt; 0)
        newCapacity = minimumCapacity;
    if (newCapacity &amp;lt; 0) {
        if (minimumCapacity &amp;lt; 0) // overflow
            throw new OutOfMemoryError();
        newCapacity = Integer.MAX_VALUE;
    }
    value = Arrays.copyOf(value, newCapacity);
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class StringBuilder extends AbstractStringBuilder {
    public StringBuilder() {
        super(16);
    }&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
public String toString() {
    // Create a copy, don&#39;t share the array
    return new String(value, 0, count);
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public class Client {
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder();
        final int count = 26;
        for (int i = 0; i &amp;lt; count; i++) {
            sb.append((char) (&#39;a&#39; + i));
        }
        System.out.println(sb.toString());
    }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;html
abcdefghijklmnopqrstuvwxyz
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;jdk-3&quot;&gt;JDK&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html&quot;&gt;java.lang.StringBuilder&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html#put-byte-&quot;&gt;java.nio.ByteBuffer&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html#append-boolean-&quot;&gt;java.lang.StringBuffer&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/Appendable.html&quot;&gt;java.lang.Appendable&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/apache/camel/tree/0e195428ee04531be27a0b659005e3aa8d159d23/camel-core/src/main/java/org/apache/camel/builder&quot;&gt;Apache Camel builders&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;prototype&quot;&gt;6. 原型模式（Prototype）&lt;/h2&gt;

&lt;h3 id=&quot;intent-5&quot;&gt;Intent&lt;/h3&gt;

&lt;p&gt;使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。&lt;/p&gt;

&lt;h3 id=&quot;class-diagram-5&quot;&gt;Class Diagram&lt;/h3&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/a40661e4-1a71-46d2-a158-ff36f7fc3331.png&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;implementation-5&quot;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public abstract class Prototype {
    abstract Prototype myClone();
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;```java
public class ConcretePrototype extends Prototype {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private String filed;

public ConcretePrototype(String filed) {
    this.filed = filed;
}

@Override
Prototype myClone() {
    return new ConcretePrototype(filed);
}

@Override
public String toString() {
    return filed;
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public class Client {
    public static void main(String[] args) {
        Prototype prototype = new ConcretePrototype(&quot;abc&quot;);
        Prototype clone = prototype.myClone();
        System.out.println(clone.toString());
    }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;html
abc
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;jdk-4&quot;&gt;JDK&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#clone%28%29&quot;&gt;java.lang.Object#clone()&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section-8&quot;&gt;三、行为型&lt;/h1&gt;

&lt;h2 id=&quot;chain-of-responsibility&quot;&gt;1. 责任链（Chain Of Responsibility）&lt;/h2&gt;

&lt;h3 id=&quot;intent-6&quot;&gt;Intent&lt;/h3&gt;

&lt;p&gt;使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。&lt;/p&gt;

&lt;h3 id=&quot;class-diagram-6&quot;&gt;Class Diagram&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Handler：定义处理请求的接口，并且实现后继链（successor）&lt;/li&gt;
&lt;/ul&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/691f11eb-31a7-46be-9de1-61f433c4b3c7.png&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;implementation-6&quot;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;```java
public abstract class Handler {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected Handler successor;


public Handler(Handler successor) {
    this.successor = successor;
}


protected abstract void handleRequest(Request request); } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class ConcreteHandler1 extends Handler {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ConcreteHandler1(Handler successor) {
    super(successor);
}


@Override
protected void handleRequest(Request request) {
    if (request.getType() == RequestType.TYPE1) {
        System.out.println(request.getName() + &quot; is handle by ConcreteHandler1&quot;);
        return;
    }
    if (successor != null) {
        successor.handleRequest(request);
    }
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class ConcreteHandler2 extends Handler {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ConcreteHandler2(Handler successor) {
    super(successor);
}


@Override
protected void handleRequest(Request request) {
    if (request.getType() == RequestType.TYPE2) {
        System.out.println(request.getName() + &quot; is handle by ConcreteHandler2&quot;);
        return;
    }
    if (successor != null) {
        successor.handleRequest(request);
    }
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class Request {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private RequestType type;
private String name;


public Request(RequestType type, String name) {
    this.type = type;
    this.name = name;
}


public RequestType getType() {
    return type;
}


public String getName() {
    return name;
} }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public enum RequestType {
    TYPE1, TYPE2
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;```java
public class Client {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main(String[] args) {

    Handler handler1 = new ConcreteHandler1(null);
    Handler handler2 = new ConcreteHandler2(handler1);

    Request request1 = new Request(RequestType.TYPE1, &quot;request1&quot;);
    handler2.handleRequest(request1);

    Request request2 = new Request(RequestType.TYPE2, &quot;request2&quot;);
    handler2.handleRequest(request2);
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;html
request1 is handle by ConcreteHandler1
request2 is handle by ConcreteHandler2
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;jdk-5&quot;&gt;JDK&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/logging/Logger.html#log%28java.util.logging.Level,%20java.lang.String%29&quot;&gt;java.util.logging.Logger#log()&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://commons.apache.org/proper/commons-chain/index.html&quot;&gt;Apache Commons Chain&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javaee/7/api/javax/servlet/Filter.html#doFilter-javax.servlet.ServletRequest-javax.servlet.ServletResponse-javax.servlet.FilterChain-&quot;&gt;javax.servlet.Filter#doFilter()&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;command&quot;&gt;2. 命令（Command）&lt;/h2&gt;

&lt;h3 id=&quot;intent-7&quot;&gt;Intent&lt;/h3&gt;

&lt;p&gt;将命令封装成对象中，具有以下作用：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用命令来参数化其它对象&lt;/li&gt;
  &lt;li&gt;将命令放入队列中进行排队&lt;/li&gt;
  &lt;li&gt;将命令的操作记录到日志中&lt;/li&gt;
  &lt;li&gt;支持可撤销的操作&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;class-diagram-7&quot;&gt;Class Diagram&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Command：命令&lt;/li&gt;
  &lt;li&gt;Receiver：命令接收者，也就是命令真正的执行者&lt;/li&gt;
  &lt;li&gt;Invoker：通过它来调用命令&lt;/li&gt;
  &lt;li&gt;Client：可以设置命令与命令的接收者&lt;/li&gt;
&lt;/ul&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/ae1b27b8-bc13-42e7-ac12-a2242e125499.png&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;implementation-7&quot;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;设计一个遥控器，可以控制电灯开关。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/e6bded8e-41a0-489a-88a6-638e88ab7666.jpg&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public interface Command {
    void execute();
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;```java
public class LightOnCommand implements Command {
    Light light;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public LightOnCommand(Light light) {
    this.light = light;
}

@Override
public void execute() {
    light.on();
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class LightOffCommand implements Command {
    Light light;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public LightOffCommand(Light light) {
    this.light = light;
}

@Override
public void execute() {
    light.off();
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class Light {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void on() {
    System.out.println(&quot;Light is on!&quot;);
}

public void off() {
    System.out.println(&quot;Light is off!&quot;);
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
/**
 * 遥控器
 */
public class Invoker {
    private Command[] onCommands;
    private Command[] offCommands;
    private final int slotNum = 7;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public Invoker() {
    this.onCommands = new Command[slotNum];
    this.offCommands = new Command[slotNum];
}

public void setOnCommand(Command command, int slot) {
    onCommands[slot] = command;
}

public void setOffCommand(Command command, int slot) {
    offCommands[slot] = command;
}

public void onButtonWasPushed(int slot) {
    onCommands[slot].execute();
}

public void offButtonWasPushed(int slot) {
    offCommands[slot].execute();
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public class Client {
    public static void main(String[] args) {
        Invoker invoker = new Invoker();
        Light light = new Light();
        Command lightOnCommand = new LightOnCommand(light);
        Command lightOffCommand = new LightOffCommand(light);
        invoker.setOnCommand(lightOnCommand, 0);
        invoker.setOffCommand(lightOffCommand, 0);
        invoker.onButtonWasPushed(0);
        invoker.offButtonWasPushed(0);
    }
}
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;jdk-6&quot;&gt;JDK&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html&quot;&gt;java.lang.Runnable&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Netflix/Hystrix/wiki&quot;&gt;Netflix Hystrix&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/javax/swing/Action.html&quot;&gt;javax.swing.Action&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;interpreter&quot;&gt;3. 解释器（Interpreter）&lt;/h2&gt;

&lt;h3 id=&quot;intent-8&quot;&gt;Intent&lt;/h3&gt;

&lt;p&gt;为语言创建解释器，通常由语言的语法和语法分析来定义。&lt;/p&gt;

&lt;h3 id=&quot;class-diagram-8&quot;&gt;Class Diagram&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;TerminalExpression：终结符表达式，每个终结符都需要一个 TerminalExpression。&lt;/li&gt;
  &lt;li&gt;Context：上下文，包含解释器之外的一些全局信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/794239e3-4baf-4aad-92df-f02f59b2a6fe.png&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;implementation-8&quot;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;以下是一个规则检验器实现，具有 and 和 or 规则，通过规则可以构建一颗解析树，用来检验一个文本是否满足解析树定义的规则。&lt;/p&gt;

&lt;p&gt;例如一颗解析树为 D And (A Or (B C))，文本 “D A” 满足该解析树定义的规则。&lt;/p&gt;

&lt;p&gt;这里的 Context 指的是 String。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public abstract class Expression {
    public abstract boolean interpret(String str);
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;```java
public class TerminalExpression extends Expression {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private String literal = null;

public TerminalExpression(String str) {
    literal = str;
}

public boolean interpret(String str) {
    StringTokenizer st = new StringTokenizer(str);
    while (st.hasMoreTokens()) {
        String test = st.nextToken();
        if (test.equals(literal)) {
            return true;
        }
    }
    return false;
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class AndExpression extends Expression {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private Expression expression1 = null;
private Expression expression2 = null;

public AndExpression(Expression expression1, Expression expression2) {
    this.expression1 = expression1;
    this.expression2 = expression2;
}

public boolean interpret(String str) {
    return expression1.interpret(str) &amp;amp;&amp;amp; expression2.interpret(str);
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class OrExpression extends Expression {
    private Expression expression1 = null;
    private Expression expression2 = null;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public OrExpression(Expression expression1, Expression expression2) {
    this.expression1 = expression1;
    this.expression2 = expression2;
}

public boolean interpret(String str) {
    return expression1.interpret(str) || expression2.interpret(str);
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class Client {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 构建解析树
 */
public static Expression buildInterpreterTree() {
    // Literal
    Expression terminal1 = new TerminalExpression(&quot;A&quot;);
    Expression terminal2 = new TerminalExpression(&quot;B&quot;);
    Expression terminal3 = new TerminalExpression(&quot;C&quot;);
    Expression terminal4 = new TerminalExpression(&quot;D&quot;);
    // B C
    Expression alternation1 = new OrExpression(terminal2, terminal3);
    // A Or (B C)
    Expression alternation2 = new OrExpression(terminal1, alternation1);
    // D And (A Or (B C))
    return new AndExpression(terminal4, alternation2);
}

public static void main(String[] args) {
    Expression define = buildInterpreterTree();
    String context1 = &quot;D A&quot;;
    String context2 = &quot;A B&quot;;
    System.out.println(define.interpret(context1));
    System.out.println(define.interpret(context2));
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;html
true
false
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;jdk-7&quot;&gt;JDK&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html&quot;&gt;java.util.Pattern&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/text/Normalizer.html&quot;&gt;java.text.Normalizer&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;All subclasses of &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/text/Format.html&quot;&gt;java.text.Format&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javaee/7/api/javax/el/ELResolver.html&quot;&gt;javax.el.ELResolver&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;iterator&quot;&gt;4. 迭代器（Iterator）&lt;/h2&gt;

&lt;h3 id=&quot;intent-9&quot;&gt;Intent&lt;/h3&gt;

&lt;p&gt;提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。&lt;/p&gt;

&lt;h3 id=&quot;class-diagram-9&quot;&gt;Class Diagram&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Aggregate 是聚合类，其中 createIterator() 方法可以产生一个 Iterator；&lt;/li&gt;
  &lt;li&gt;Iterator 主要定义了 hasNext() 和 next() 方法。&lt;/li&gt;
  &lt;li&gt;Client 组合了 Aggregate，为了迭代遍历 Aggregate，也需要组合 Iterator。&lt;/li&gt;
&lt;/ul&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/b0f61ac2-a4b6-4042-9cf0-ccf4238c1ff7.png&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;implementation-9&quot;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public interface Aggregate {
    Iterator createIterator();
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;```java
public class ConcreteAggregate implements Aggregate {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private Integer[] items;

public ConcreteAggregate() {
    items = new Integer[10];
    for (int i = 0; i &amp;lt; items.length; i++) {
        items[i] = i;
    }
}

@Override
public Iterator createIterator() {
    return new ConcreteIterator&amp;lt;Integer&amp;gt;(items);
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public interface Iterator&lt;item&gt; {&lt;/item&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Item next();

boolean hasNext(); } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class ConcreteIterator&lt;item&gt; implements Iterator {&lt;/item&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private Item[] items;
private int position = 0;

public ConcreteIterator(Item[] items) {
    this.items = items;
}

@Override
public Object next() {
    return items[position++];
}

@Override
public boolean hasNext() {
    return position &amp;lt; items.length;
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class Client {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main(String[] args) {
    Aggregate aggregate = new ConcreteAggregate();
    Iterator&amp;lt;Integer&amp;gt; iterator = aggregate.createIterator();
    while (iterator.hasNext()) {
        System.out.println(iterator.next());
    }
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;jdk-8&quot;&gt;JDK&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html&quot;&gt;java.util.Iterator&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/Enumeration.html&quot;&gt;java.util.Enumeration&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mediator&quot;&gt;5. 中介者（Mediator）&lt;/h2&gt;

&lt;h3 id=&quot;intent-10&quot;&gt;Intent&lt;/h3&gt;

&lt;p&gt;集中相关对象之间复杂的沟通和控制方式。&lt;/p&gt;

&lt;h3 id=&quot;class-diagram-10&quot;&gt;Class Diagram&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Mediator：中介者，定义一个接口用于与各同事（Colleague）对象通信。&lt;/li&gt;
  &lt;li&gt;Colleague：同事，相关对象&lt;/li&gt;
&lt;/ul&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/d0afdd23-c9a5-4d1c-9b3d-404bff3bd0d1.png&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;implementation-10&quot;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;Alarm（闹钟）、CoffeePot（咖啡壶）、Calendar（日历）、Sprinkler（喷头）是一组相关的对象，在某个对象的事件产生时需要去操作其它对象，形成了下面这种依赖结构：&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/82cfda3b-b53b-4c89-9fdb-26dd2db0cd02.jpg&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;使用中介者模式可以将复杂的依赖结构变成星形结构：&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/5359cbf5-5a79-4874-9b17-f23c53c2cb80.jpg&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public abstract class Colleague {
    public abstract void onEvent(Mediator mediator);
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;```java
public class Alarm extends Colleague {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
public void onEvent(Mediator mediator) {
    mediator.doEvent(&quot;alarm&quot;);
}

public void doAlarm() {
    System.out.println(&quot;doAlarm()&quot;);
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class CoffeePot extends Colleague {
    @Override
    public void onEvent(Mediator mediator) {
        mediator.doEvent(“coffeePot”);
    }&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void doCoffeePot() {
    System.out.println(&quot;doCoffeePot()&quot;);
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class Calender extends Colleague {
    @Override
    public void onEvent(Mediator mediator) {
        mediator.doEvent(“calender”);
    }&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void doCalender() {
    System.out.println(&quot;doCalender()&quot;);
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class Sprinkler extends Colleague {
    @Override
    public void onEvent(Mediator mediator) {
        mediator.doEvent(“sprinkler”);
    }&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void doSprinkler() {
    System.out.println(&quot;doSprinkler()&quot;);
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public abstract class Mediator {
    public abstract void doEvent(String eventType);
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;```java
public class ConcreteMediator extends Mediator {
    private Alarm alarm;
    private CoffeePot coffeePot;
    private Calender calender;
    private Sprinkler sprinkler;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ConcreteMediator(Alarm alarm, CoffeePot coffeePot, Calender calender, Sprinkler sprinkler) {
    this.alarm = alarm;
    this.coffeePot = coffeePot;
    this.calender = calender;
    this.sprinkler = sprinkler;
}

@Override
public void doEvent(String eventType) {
    switch (eventType) {
        case &quot;alarm&quot;:
            doAlarmEvent();
            break;
        case &quot;coffeePot&quot;:
            doCoffeePotEvent();
            break;
        case &quot;calender&quot;:
            doCalenderEvent();
            break;
        default:
            doSprinklerEvent();
    }
}

public void doAlarmEvent() {
    alarm.doAlarm();
    coffeePot.doCoffeePot();
    calender.doCalender();
    sprinkler.doSprinkler();
}

public void doCoffeePotEvent() {
    // ...
}

public void doCalenderEvent() {
    // ...
}

public void doSprinklerEvent() {
    // ...
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public class Client {
    public static void main(String[] args) {
        Alarm alarm = new Alarm();
        CoffeePot coffeePot = new CoffeePot();
        Calender calender = new Calender();
        Sprinkler sprinkler = new Sprinkler();
        Mediator mediator = new ConcreteMediator(alarm, coffeePot, calender, sprinkler);
        // 闹钟事件到达，调用中介者就可以操作相关对象
        alarm.onEvent(mediator);
    }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
doAlarm()
doCoffeePot()
doCalender()
doSprinkler()
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;jdk-9&quot;&gt;JDK&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;All scheduleXXX() methods of &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/Timer.html&quot;&gt;java.util.Timer&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html#execute-java.lang.Runnable-&quot;&gt;java.util.concurrent.Executor#execute()&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;submit() and invokeXXX() methods of &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html&quot;&gt;java.util.concurrent.ExecutorService&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;scheduleXXX() methods of &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html&quot;&gt;java.util.concurrent.ScheduledExecutorService&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html#invoke-java.lang.Object-java.lang.Object...-&quot;&gt;java.lang.reflect.Method#invoke()&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;memento&quot;&gt;6. 备忘录（Memento）&lt;/h2&gt;

&lt;h3 id=&quot;intent-11&quot;&gt;Intent&lt;/h3&gt;

&lt;p&gt;在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态。&lt;/p&gt;

&lt;h3 id=&quot;class-diagram-11&quot;&gt;Class Diagram&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Originator：原始对象&lt;/li&gt;
  &lt;li&gt;Caretaker：负责保存好备忘录&lt;/li&gt;
  &lt;li&gt;Menento：备忘录，存储原始对象的的状态。备忘录实际上有两个接口，一个是提供给 Caretaker 的窄接口：它只能将备忘录传递给其它对象；一个是提供给 Originator 的宽接口，允许它访问到先前状态所需的所有数据。理想情况是只允许 Originator 访问本备忘录的内部状态。&lt;/li&gt;
&lt;/ul&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/867e93eb-3161-4f39-b2d2-c0cd3788e194.png&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;implementation-11&quot;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;以下实现了一个简单计算器程序，可以输入两个值，然后计算这两个值的和。备忘录模式允许将这两个值存储起来，然后在某个时刻用存储的状态进行恢复。&lt;/p&gt;

&lt;p&gt;实现参考：&lt;a href=&quot;https://www.oodesign.com/memento-pattern-calculator-example-java-sourcecode.html&quot;&gt;Memento Pattern - Calculator Example - Java Sourcecode&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;```java
/**
 * Originator Interface
 */
public interface Calculator {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Create Memento
PreviousCalculationToCareTaker backupLastCalculation();

// setMemento
void restorePreviousCalculation(PreviousCalculationToCareTaker memento);

int getCalculationResult();

void setFirstNumber(int firstNumber);

void setSecondNumber(int secondNumber); } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
/**
 * Originator Implementation
 */
public class CalculatorImp implements Calculator {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private int firstNumber;
private int secondNumber;

@Override
public PreviousCalculationToCareTaker backupLastCalculation() {
    // create a memento object used for restoring two numbers
    return new PreviousCalculationImp(firstNumber, secondNumber);
}

@Override
public void restorePreviousCalculation(PreviousCalculationToCareTaker memento) {
    this.firstNumber = ((PreviousCalculationToOriginator) memento).getFirstNumber();
    this.secondNumber = ((PreviousCalculationToOriginator) memento).getSecondNumber();
}

@Override
public int getCalculationResult() {
    // result is adding two numbers
    return firstNumber + secondNumber;
}

@Override
public void setFirstNumber(int firstNumber) {
    this.firstNumber = firstNumber;
}

@Override
public void setSecondNumber(int secondNumber) {
    this.secondNumber = secondNumber;
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
/**
 * Memento Interface to Originator
 *
 * This interface allows the originator to restore its state
 */
public interface PreviousCalculationToOriginator {
    int getFirstNumber();
    int getSecondNumber();
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
/**
 *  Memento interface to CalculatorOperator (Caretaker)
 */
public interface PreviousCalculationToCareTaker {
    // no operations permitted for the caretaker
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;```java
/**
 * Memento Object Implementation
 * &amp;lt;p&amp;gt;
 * Note that this object implements both interfaces to Originator and CareTaker
 */
public class PreviousCalculationImp implements PreviousCalculationToCareTaker,
        PreviousCalculationToOriginator {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private int firstNumber;
private int secondNumber;

public PreviousCalculationImp(int firstNumber, int secondNumber) {
    this.firstNumber = firstNumber;
    this.secondNumber = secondNumber;
}

@Override
public int getFirstNumber() {
    return firstNumber;
}

@Override
public int getSecondNumber() {
    return secondNumber;
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
/**
 * CareTaker object
 */
public class Client {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main(String[] args) {
    // program starts
    Calculator calculator = new CalculatorImp();

    // assume user enters two numbers
    calculator.setFirstNumber(10);
    calculator.setSecondNumber(100);

    // find result
    System.out.println(calculator.getCalculationResult());

    // Store result of this calculation in case of error
    PreviousCalculationToCareTaker memento = calculator.backupLastCalculation();

    // user enters a number
    calculator.setFirstNumber(17);

    // user enters a wrong second number and calculates result
    calculator.setSecondNumber(-290);

    // calculate result
    System.out.println(calculator.getCalculationResult());

    // user hits CTRL + Z to undo last operation and see last result
    calculator.restorePreviousCalculation(memento);

    // result restored
    System.out.println(calculator.getCalculationResult());
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;html
110
-273
110
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;jdk-10&quot;&gt;JDK&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;java.io.Serializable&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;observer&quot;&gt;7. 观察者（Observer）&lt;/h2&gt;

&lt;h3 id=&quot;intent-12&quot;&gt;Intent&lt;/h3&gt;

&lt;p&gt;定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。&lt;/p&gt;

&lt;p&gt;主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/7a3c6a30-c735-4edb-8115-337288a4f0f2.jpg&quot; width=&quot;600&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;class-diagram-12&quot;&gt;Class Diagram&lt;/h3&gt;

&lt;p&gt;主题（Subject）具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。&lt;/p&gt;

&lt;p&gt;观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/0df5d84c-e7ca-4e3a-a688-bb8e68894467.png&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;implementation-12&quot;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;天气数据布告板会在天气信息发生改变时更新其内容，布告板有多个，并且在将来会继续增加。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/b1df9732-86ce-4d69-9f06-fba1db7b3b5a.jpg&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;```java
public interface Subject {
    void registerObserver(Observer o);&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void removeObserver(Observer o);

void notifyObserver(); } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class WeatherData implements Subject {
    private List&lt;observer&gt; observers;
    private float temperature;
    private float humidity;
    private float pressure;&lt;/observer&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public WeatherData() {
    observers = new ArrayList&amp;lt;&amp;gt;();
}

public void setMeasurements(float temperature, float humidity, float pressure) {
    this.temperature = temperature;
    this.humidity = humidity;
    this.pressure = pressure;
    notifyObserver();
}

@Override
public void registerObserver(Observer o) {
    observers.add(o);
}

@Override
public void removeObserver(Observer o) {
    int i = observers.indexOf(o);
    if (i &amp;gt;= 0) {
        observers.remove(i);
    }
}

@Override
public void notifyObserver() {
    for (Observer o : observers) {
        o.update(temperature, humidity, pressure);
    }
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public interface Observer {
    void update(float temp, float humidity, float pressure);
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;```java
public class StatisticsDisplay implements Observer {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public StatisticsDisplay(Subject weatherData) {
    weatherData.reisterObserver(this);
}

@Override
public void update(float temp, float humidity, float pressure) {
    System.out.println(&quot;StatisticsDisplay.update: &quot; + temp + &quot; &quot; + humidity + &quot; &quot; + pressure);
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class CurrentConditionsDisplay implements Observer {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public CurrentConditionsDisplay(Subject weatherData) {
    weatherData.registerObserver(this);
}

@Override
public void update(float temp, float humidity, float pressure) {
    System.out.println(&quot;CurrentConditionsDisplay.update: &quot; + temp + &quot; &quot; + humidity + &quot; &quot; + pressure);
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class WeatherStation {
    public static void main(String[] args) {
        WeatherData weatherData = new WeatherData();
        CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(weatherData);
        StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData);&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    weatherData.setMeasurements(0, 0, 0);
    weatherData.setMeasurements(1, 1, 1);
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;html
CurrentConditionsDisplay.update: 0.0 0.0 0.0
StatisticsDisplay.update: 0.0 0.0 0.0
CurrentConditionsDisplay.update: 1.0 1.0 1.0
StatisticsDisplay.update: 1.0 1.0 1.0
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;jdk-11&quot;&gt;JDK&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/Observer.html&quot;&gt;java.util.Observer&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/EventListener.html&quot;&gt;java.util.EventListener&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSessionBindingListener.html&quot;&gt;javax.servlet.http.HttpSessionBindingListener&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ReactiveX/RxJava&quot;&gt;RxJava&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;state&quot;&gt;8. 状态（State）&lt;/h2&gt;

&lt;h3 id=&quot;intent-13&quot;&gt;Intent&lt;/h3&gt;

&lt;p&gt;允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。&lt;/p&gt;

&lt;h3 id=&quot;class-diagram-13&quot;&gt;Class Diagram&lt;/h3&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/c5085437-54df-4304-b62d-44b961711ba7.png&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;implementation-13&quot;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;糖果销售机有多种状态，每种状态下销售机有不同的行为，状态可以发生转移，使得销售机的行为也发生改变。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/396be981-3f2c-4fd9-8101-dbf9c841504b.jpg&quot; width=&quot;600&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;```java
public interface State {
    /**
     * 投入 25 分钱
     */
    void insertQuarter();&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 退回 25 分钱
 */
void ejectQuarter();

/**
 * 转动曲柄
 */
void turnCrank();

/**
 * 发放糖果
 */
void dispense(); } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class HasQuarterState implements State {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private GumballMachine gumballMachine;

public HasQuarterState(GumballMachine gumballMachine) {
    this.gumballMachine = gumballMachine;
}

@Override
public void insertQuarter() {
    System.out.println(&quot;You can&#39;t insert another quarter&quot;);
}

@Override
public void ejectQuarter() {
    System.out.println(&quot;Quarter returned&quot;);
    gumballMachine.setState(gumballMachine.getNoQuarterState());
}

@Override
public void turnCrank() {
    System.out.println(&quot;You turned...&quot;);
    gumballMachine.setState(gumballMachine.getSoldState());
}

@Override
public void dispense() {
    System.out.println(&quot;No gumball dispensed&quot;);
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class NoQuarterState implements State {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GumballMachine gumballMachine;

public NoQuarterState(GumballMachine gumballMachine) {
    this.gumballMachine = gumballMachine;
}

@Override
public void insertQuarter() {
    System.out.println(&quot;You insert a quarter&quot;);
    gumballMachine.setState(gumballMachine.getHasQuarterState());
}

@Override
public void ejectQuarter() {
    System.out.println(&quot;You haven&#39;t insert a quarter&quot;);
}

@Override
public void turnCrank() {
    System.out.println(&quot;You turned, but there&#39;s no quarter&quot;);
}

@Override
public void dispense() {
    System.out.println(&quot;You need to pay first&quot;);
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class SoldOutState implements State {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GumballMachine gumballMachine;

public SoldOutState(GumballMachine gumballMachine) {
    this.gumballMachine = gumballMachine;
}

@Override
public void insertQuarter() {
    System.out.println(&quot;You can&#39;t insert a quarter, the machine is sold out&quot;);
}

@Override
public void ejectQuarter() {
    System.out.println(&quot;You can&#39;t eject, you haven&#39;t inserted a quarter yet&quot;);
}

@Override
public void turnCrank() {
    System.out.println(&quot;You turned, but there are no gumballs&quot;);
}

@Override
public void dispense() {
    System.out.println(&quot;No gumball dispensed&quot;);
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class SoldState implements State {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GumballMachine gumballMachine;

public SoldState(GumballMachine gumballMachine) {
    this.gumballMachine = gumballMachine;
}

@Override
public void insertQuarter() {
    System.out.println(&quot;Please wait, we&#39;re already giving you a gumball&quot;);
}

@Override
public void ejectQuarter() {
    System.out.println(&quot;Sorry, you already turned the crank&quot;);
}

@Override
public void turnCrank() {
    System.out.println(&quot;Turning twice doesn&#39;t get you another gumball!&quot;);
}

@Override
public void dispense() {
    gumballMachine.releaseBall();
    if (gumballMachine.getCount() &amp;gt; 0) {
        gumballMachine.setState(gumballMachine.getNoQuarterState());
    } else {
        System.out.println(&quot;Oops, out of gumballs&quot;);
        gumballMachine.setState(gumballMachine.getSoldOutState());
    }
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class GumballMachine {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private State soldOutState;
private State noQuarterState;
private State hasQuarterState;
private State soldState;

private State state;
private int count = 0;

public GumballMachine(int numberGumballs) {
    count = numberGumballs;
    soldOutState = new SoldOutState(this);
    noQuarterState = new NoQuarterState(this);
    hasQuarterState = new HasQuarterState(this);
    soldState = new SoldState(this);

    if (numberGumballs &amp;gt; 0) {
        state = noQuarterState;
    } else {
        state = soldOutState;
    }
}

public void insertQuarter() {
    state.insertQuarter();
}

public void ejectQuarter() {
    state.ejectQuarter();
}

public void turnCrank() {
    state.turnCrank();
    state.dispense();
}

public void setState(State state) {
    this.state = state;
}

public void releaseBall() {
    System.out.println(&quot;A gumball comes rolling out the slot...&quot;);
    if (count != 0) {
        count -= 1;
    }
}

public State getSoldOutState() {
    return soldOutState;
}

public State getNoQuarterState() {
    return noQuarterState;
}

public State getHasQuarterState() {
    return hasQuarterState;
}

public State getSoldState() {
    return soldState;
}

public int getCount() {
    return count;
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class Client {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main(String[] args) {
    GumballMachine gumballMachine = new GumballMachine(5);

    gumballMachine.insertQuarter();
    gumballMachine.turnCrank();

    gumballMachine.insertQuarter();
    gumballMachine.ejectQuarter();
    gumballMachine.turnCrank();

    gumballMachine.insertQuarter();
    gumballMachine.turnCrank();
    gumballMachine.insertQuarter();
    gumballMachine.turnCrank();
    gumballMachine.ejectQuarter();

    gumballMachine.insertQuarter();
    gumballMachine.insertQuarter();
    gumballMachine.turnCrank();
    gumballMachine.insertQuarter();
    gumballMachine.turnCrank();
    gumballMachine.insertQuarter();
    gumballMachine.turnCrank();
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;html
You insert a quarter
You turned...
A gumball comes rolling out the slot...
You insert a quarter
Quarter returned
You turned, but there&#39;s no quarter
You need to pay first
You insert a quarter
You turned...
A gumball comes rolling out the slot...
You insert a quarter
You turned...
A gumball comes rolling out the slot...
You haven&#39;t insert a quarter
You insert a quarter
You can&#39;t insert another quarter
You turned...
A gumball comes rolling out the slot...
You insert a quarter
You turned...
A gumball comes rolling out the slot...
Oops, out of gumballs
You can&#39;t insert a quarter, the machine is sold out
You turned, but there are no gumballs
No gumball dispensed
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;strategy&quot;&gt;9. 策略（Strategy）&lt;/h2&gt;

&lt;h3 id=&quot;intent-14&quot;&gt;Intent&lt;/h3&gt;

&lt;p&gt;定义一系列算法，封装每个算法，并使它们可以互换。&lt;/p&gt;

&lt;p&gt;策略模式可以让算法独立于使用它的客户端。&lt;/p&gt;

&lt;h3 id=&quot;class-diagram-14&quot;&gt;Class Diagram&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Strategy 接口定义了一个算法族，它们都实现了  behavior() 方法。&lt;/li&gt;
  &lt;li&gt;Context 是使用到该算法族的类，其中的 doSomething() 方法会调用 behavior()，setStrategy(Strategy) 方法可以动态地改变 strategy 对象，也就是说能动态地改变 Context 所使用的算法。&lt;/li&gt;
&lt;/ul&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/1fc969e4-0e7c-441b-b53c-01950d2f2be5.png&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;与状态模式的比较&lt;/h3&gt;

&lt;p&gt;状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是状态模式是通过状态转移来改变 Context 所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中。&lt;/p&gt;

&lt;p&gt;状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。&lt;/p&gt;

&lt;h3 id=&quot;implementation-14&quot;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;设计一个鸭子，它可以动态地改变叫声。这里的算法族是鸭子的叫声行为。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public interface QuackBehavior {
    void quack();
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public class Quack implements QuackBehavior {
    @Override
    public void quack() {
        System.out.println(&quot;quack!&quot;);
    }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public class Squeak implements QuackBehavior{
    @Override
    public void quack() {
        System.out.println(&quot;squeak!&quot;);
    }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;```java
public class Duck {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private QuackBehavior quackBehavior;

public void performQuack() {
    if (quackBehavior != null) {
        quackBehavior.quack();
    }
}

public void setQuackBehavior(QuackBehavior quackBehavior) {
    this.quackBehavior = quackBehavior;
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class Client {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main(String[] args) {
    Duck duck = new Duck();
    duck.setQuackBehavior(new Squeak());
    duck.performQuack();
    duck.setQuackBehavior(new Quack());
    duck.performQuack();
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;html
squeak!
quack!
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;jdk-12&quot;&gt;JDK&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;java.util.Comparator#compare()&lt;/li&gt;
  &lt;li&gt;javax.servlet.http.HttpServlet&lt;/li&gt;
  &lt;li&gt;javax.servlet.Filter#doFilter()&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;template-method&quot;&gt;10. 模板方法（Template Method）&lt;/h2&gt;

&lt;h3 id=&quot;intent-15&quot;&gt;Intent&lt;/h3&gt;

&lt;p&gt;定义算法框架，并将一些步骤的实现延迟到子类。&lt;/p&gt;

&lt;p&gt;通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。&lt;/p&gt;

&lt;h3 id=&quot;class-diagram-15&quot;&gt;Class Diagram&lt;/h3&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/c3c1c0e8-3a78-4426-961f-b46dd0879dd8.png&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;implementation-15&quot;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;冲咖啡和冲茶都有类似的流程，但是某些步骤会有点不一样，要求复用那些相同步骤的代码。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/11236498-1417-46ce-a1b0-e10054256955.png&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;```java
public abstract class CaffeineBeverage {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;final void prepareRecipe() {
    boilWater();
    brew();
    pourInCup();
    addCondiments();
}

abstract void brew();

abstract void addCondiments();

void boilWater() {
    System.out.println(&quot;boilWater&quot;);
}

void pourInCup() {
    System.out.println(&quot;pourInCup&quot;);
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class Coffee extends CaffeineBeverage {
    @Override
    void brew() {
        System.out.println(“Coffee.brew”);
    }&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
void addCondiments() {
    System.out.println(&quot;Coffee.addCondiments&quot;);
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class Tea extends CaffeineBeverage {
    @Override
    void brew() {
        System.out.println(“Tea.brew”);
    }&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
void addCondiments() {
    System.out.println(&quot;Tea.addCondiments&quot;);
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public class Client {
    public static void main(String[] args) {
        CaffeineBeverage caffeineBeverage = new Coffee();
        caffeineBeverage.prepareRecipe();
        System.out.println(&quot;-----------&quot;);
        caffeineBeverage = new Tea();
        caffeineBeverage.prepareRecipe();
    }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;html
boilWater
Coffee.brew
pourInCup
Coffee.addCondiments
-----------
boilWater
Tea.brew
pourInCup
Tea.addCondiments
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;jdk-13&quot;&gt;JDK&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;java.util.Collections#sort()&lt;/li&gt;
  &lt;li&gt;java.io.InputStream#skip()&lt;/li&gt;
  &lt;li&gt;java.io.InputStream#read()&lt;/li&gt;
  &lt;li&gt;java.util.AbstractList#indexOf()&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;visitor&quot;&gt;11. 访问者（Visitor）&lt;/h2&gt;

&lt;h3 id=&quot;intent-16&quot;&gt;Intent&lt;/h3&gt;

&lt;p&gt;为一个对象结构（比如组合结构）增加新能力。&lt;/p&gt;

&lt;h3 id=&quot;class-diagram-16&quot;&gt;Class Diagram&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Visitor：访问者，为每一个 ConcreteElement 声明一个 visit 操作&lt;/li&gt;
  &lt;li&gt;ConcreteVisitor：具体访问者，存储遍历过程中的累计结果&lt;/li&gt;
  &lt;li&gt;ObjectStructure：对象结构，可以是组合结构，或者是一个集合。&lt;/li&gt;
&lt;/ul&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/ec923dc7-864c-47b0-a411-1f2c48d084de.png&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;implementation-16&quot;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public interface Element {
    void accept(Visitor visitor);
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;```java
class CustomerGroup {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private List&amp;lt;Customer&amp;gt; customers = new ArrayList&amp;lt;&amp;gt;();

void accept(Visitor visitor) {
    for (Customer customer : customers) {
        customer.accept(visitor);
    }
}

void addCustomer(Customer customer) {
    customers.add(customer);
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class Customer implements Element {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private String name;
private List&amp;lt;Order&amp;gt; orders = new ArrayList&amp;lt;&amp;gt;();

Customer(String name) {
    this.name = name;
}

String getName() {
    return name;
}

void addOrder(Order order) {
    orders.add(order);
}

public void accept(Visitor visitor) {
    visitor.visit(this);
    for (Order order : orders) {
        order.accept(visitor);
    }
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class Order implements Element {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private String name;
private List&amp;lt;Item&amp;gt; items = new ArrayList();

Order(String name) {
    this.name = name;
}

Order(String name, String itemName) {
    this.name = name;
    this.addItem(new Item(itemName));
}

String getName() {
    return name;
}

void addItem(Item item) {
    items.add(item);
}

public void accept(Visitor visitor) {
    visitor.visit(this);

    for (Item item : items) {
        item.accept(visitor);
    }
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class Item implements Element {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private String name;

Item(String name) {
    this.name = name;
}

String getName() {
    return name;
}

public void accept(Visitor visitor) {
    visitor.visit(this);
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public interface Visitor {
    void visit(Customer customer);&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void visit(Order order);

void visit(Item item); } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class GeneralReport implements Visitor {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private int customersNo;
private int ordersNo;
private int itemsNo;

public void visit(Customer customer) {
    System.out.println(customer.getName());
    customersNo++;
}

public void visit(Order order) {
    System.out.println(order.getName());
    ordersNo++;
}

public void visit(Item item) {
    System.out.println(item.getName());
    itemsNo++;
}

public void displayResults() {
    System.out.println(&quot;Number of customers: &quot; + customersNo);
    System.out.println(&quot;Number of orders:    &quot; + ordersNo);
    System.out.println(&quot;Number of items:     &quot; + itemsNo);
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class Client {
    public static void main(String[] args) {
        Customer customer1 = new Customer(“customer1”);
        customer1.addOrder(new Order(“order1”, “item1”));
        customer1.addOrder(new Order(“order2”, “item1”));
        customer1.addOrder(new Order(“order3”, “item1”));&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Order order = new Order(&quot;order_a&quot;);
    order.addItem(new Item(&quot;item_a1&quot;));
    order.addItem(new Item(&quot;item_a2&quot;));
    order.addItem(new Item(&quot;item_a3&quot;));
    Customer customer2 = new Customer(&quot;customer2&quot;);
    customer2.addOrder(order);

    CustomerGroup customers = new CustomerGroup();
    customers.addCustomer(customer1);
    customers.addCustomer(customer2);

    GeneralReport visitor = new GeneralReport();
    customers.accept(visitor);
    visitor.displayResults();
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;html
customer1
order1
item1
order2
item1
order3
item1
customer2
order_a
item_a1
item_a2
item_a3
Number of customers: 2
Number of orders:    4
Number of items:     6
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;jdk-14&quot;&gt;JDK&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;javax.lang.model.element.Element and javax.lang.model.element.ElementVisitor&lt;/li&gt;
  &lt;li&gt;javax.lang.model.type.TypeMirror and javax.lang.model.type.TypeVisitor&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;null&quot;&gt;12. 空对象（Null）&lt;/h2&gt;

&lt;h3 id=&quot;intent-17&quot;&gt;Intent&lt;/h3&gt;

&lt;p&gt;使用什么都不做的空对象来代替 NULL。&lt;/p&gt;

&lt;p&gt;一个方法返回 NULL，意味着方法的调用端需要去检查返回值是否是 NULL，这么做会导致非常多的冗余的检查代码。并且如果某一个调用端忘记了做这个检查返回值，而直接使用返回的对象，那么就有可能抛出空指针异常。&lt;/p&gt;

&lt;h3 id=&quot;class-diagram-17&quot;&gt;Class Diagram&lt;/h3&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/dd3b289c-d90e-44a6-a44c-4880517eb1de.png&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;implementation-17&quot;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public abstract class AbstractOperation {
    abstract void request();
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public class RealOperation extends AbstractOperation {
    @Override
    void request() {
        System.out.println(&quot;do something&quot;);
    }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public class NullOperation extends AbstractOperation{
    @Override
    void request() {
        // do nothing
    }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;```java
public class Client {
    public static void main(String[] args) {
        AbstractOperation abstractOperation = func(-1);
        abstractOperation.request();
    }&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static AbstractOperation func(int para) {
    if (para &amp;lt; 0) {
        return new NullOperation();
    }
    return new RealOperation();
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;section-10&quot;&gt;四、结构型&lt;/h1&gt;

&lt;h2 id=&quot;adapter&quot;&gt;1. 适配器（Adapter）&lt;/h2&gt;

&lt;h3 id=&quot;intent-18&quot;&gt;Intent&lt;/h3&gt;

&lt;p&gt;把一个类接口转换成另一个用户需要的接口。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/3d5b828e-5c4d-48d8-a440-281e4a8e1c92.png&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;class-diagram-18&quot;&gt;Class Diagram&lt;/h3&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/0889c0b4-07b4-45fc-873c-e0e16b97f67d.png&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;implementation-18&quot;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;鸭子（Duck）和火鸡（Turkey）拥有不同的叫声，Duck 的叫声调用 quack() 方法，而 Turkey 调用 gobble() 方法。&lt;/p&gt;

&lt;p&gt;要求将 Turkey 的 gobble() 方法适配成 Duck 的 quack() 方法，从而让火鸡冒充鸭子！&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public interface Duck {
    void quack();
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public interface Turkey {
    void gobble();
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public class WildTurkey implements Turkey {
    @Override
    public void gobble() {
        System.out.println(&quot;gobble!&quot;);
    }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;```java
public class TurkeyAdapter implements Duck {
    Turkey turkey;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public TurkeyAdapter(Turkey turkey) {
    this.turkey = turkey;
}

@Override
public void quack() {
    turkey.gobble();
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public class Client {
    public static void main(String[] args) {
        Turkey turkey = new WildTurkey();
        Duck duck = new TurkeyAdapter(turkey);
        duck.quack();
    }
}
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;jdk-15&quot;&gt;JDK&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList%28T...%29&quot;&gt;java.util.Arrays#asList()&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#list-java.util.Enumeration-&quot;&gt;java.util.Collections#list()&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#enumeration-java.util.Collection-&quot;&gt;java.util.Collections#enumeration()&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/adapters/XmlAdapter.html#marshal-BoundType-&quot;&gt;javax.xml.bind.annotation.adapters.XMLAdapter&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;bridge&quot;&gt;2. 桥接（Bridge）&lt;/h2&gt;

&lt;h3 id=&quot;intent-19&quot;&gt;Intent&lt;/h3&gt;

&lt;p&gt;将抽象与实现分离开来，使它们可以独立变化。&lt;/p&gt;

&lt;h3 id=&quot;class-diagram-19&quot;&gt;Class Diagram&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Abstraction：定义抽象类的接口&lt;/li&gt;
  &lt;li&gt;Implementor：定义实现类接口&lt;/li&gt;
&lt;/ul&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/c2cbf5d2-82af-4c78-bd43-495da5adf55f.png&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;implementation-19&quot;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;RemoteControl 表示遥控器，指代 Abstraction。&lt;/p&gt;

&lt;p&gt;TV 表示电视，指代 Implementor。&lt;/p&gt;

&lt;p&gt;桥接模式将遥控器和电视分离开来，从而可以独立改变遥控器或者电视的实现。&lt;/p&gt;

&lt;p&gt;```java
public abstract class TV {
    public abstract void on();&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public abstract void off();

public abstract void tuneChannel(); } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class Sony extends TV {
    @Override
    public void on() {
        System.out.println(“Sony.on()”);
    }&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
public void off() {
    System.out.println(&quot;Sony.off()&quot;);
}

@Override
public void tuneChannel() {
    System.out.println(&quot;Sony.tuneChannel()&quot;);
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class RCA extends TV {
    @Override
    public void on() {
        System.out.println(“RCA.on()”);
    }&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
public void off() {
    System.out.println(&quot;RCA.off()&quot;);
}

@Override
public void tuneChannel() {
    System.out.println(&quot;RCA.tuneChannel()&quot;);
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public abstract class RemoteControl {
    protected TV tv;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public RemoteControl(TV tv) {
    this.tv = tv;
}

public abstract void on();

public abstract void off();

public abstract void tuneChannel(); } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class ConcreteRemoteControl1 extends RemoteControl {
    public ConcreteRemoteControl1(TV tv) {
        super(tv);
    }&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
public void on() {
    System.out.println(&quot;ConcreteRemoteControl1.on()&quot;);
    tv.on();
}

@Override
public void off() {
    System.out.println(&quot;ConcreteRemoteControl1.off()&quot;);
    tv.off();
}

@Override
public void tuneChannel() {
    System.out.println(&quot;ConcreteRemoteControl1.tuneChannel()&quot;);
    tv.tuneChannel();
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class ConcreteRemoteControl2 extends RemoteControl {
    public ConcreteRemoteControl2(TV tv) {
        super(tv);
    }&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
public void on() {
    System.out.println(&quot;ConcreteRemoteControl2.on()&quot;);
    tv.on();
}

@Override
public void off() {
    System.out.println(&quot;ConcreteRemoteControl2.off()&quot;);
    tv.off();
}

@Override
public void tuneChannel() {
    System.out.println(&quot;ConcreteRemoteControl2.tuneChannel()&quot;);
    tv.tuneChannel();
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public class Client {
    public static void main(String[] args) {
        RemoteControl remoteControl1 = new ConcreteRemoteControl1(new RCA());
        remoteControl1.on();
        remoteControl1.off();
        remoteControl1.tuneChannel();
        RemoteControl remoteControl2 = new ConcreteRemoteControl2(new Sony());
         remoteControl2.on();
         remoteControl2.off();
         remoteControl2.tuneChannel();
    }
}
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;jdk-16&quot;&gt;JDK&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;AWT (It provides an abstraction layer which maps onto the native OS the windowing support.)&lt;/li&gt;
  &lt;li&gt;JDBC&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;composite&quot;&gt;3. 组合（Composite）&lt;/h2&gt;

&lt;h3 id=&quot;intent-20&quot;&gt;Intent&lt;/h3&gt;

&lt;p&gt;将对象组合成树形结构来表示“整体/部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。&lt;/p&gt;

&lt;h3 id=&quot;class-diagram-20&quot;&gt;Class Diagram&lt;/h3&gt;

&lt;p&gt;组件（Component）类是组合类（Composite）和叶子类（Leaf）的父类，可以把组合类看成是树的中间节点。&lt;/p&gt;

&lt;p&gt;组合对象拥有一个或者多个组件对象，因此组合对象的操作可以委托给组件对象去处理，而组件对象可以是另一个组合对象或者叶子对象。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/77931a4b-72ba-4016-827d-84b9a6845a51.png&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;implementation-20&quot;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;```java
public abstract class Component {
    protected String name;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public Component(String name) {
    this.name = name;
}

public void print() {
    print(0);
}

abstract void print(int level);

abstract public void add(Component component);

abstract public void remove(Component component); } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class Composite extends Component {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private List&amp;lt;Component&amp;gt; child;

public Composite(String name) {
    super(name);
    child = new ArrayList&amp;lt;&amp;gt;();
}

@Override
void print(int level) {
    for (int i = 0; i &amp;lt; level; i++) {
        System.out.print(&quot;--&quot;);
    }
    System.out.println(&quot;Composite:&quot; + name);
    for (Component component : child) {
        component.print(level + 1);
    }
}

@Override
public void add(Component component) {
    child.add(component);
}

@Override
public void remove(Component component) {
    child.remove(component);
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class Leaf extends Component {
    public Leaf(String name) {
        super(name);
    }&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
void print(int level) {
    for (int i = 0; i &amp;lt; level; i++) {
        System.out.print(&quot;--&quot;);
    }
    System.out.println(&quot;left:&quot; + name);
}

@Override
public void add(Component component) {
    throw new UnsupportedOperationException(); // 牺牲透明性换取单一职责原则，这样就不用考虑是叶子节点还是组合节点
}

@Override
public void remove(Component component) {
    throw new UnsupportedOperationException();
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public class Client {
    public static void main(String[] args) {
        Composite root = new Composite(&quot;root&quot;);
        Component node1 = new Leaf(&quot;1&quot;);
        Component node2 = new Composite(&quot;2&quot;);
        Component node3 = new Leaf(&quot;3&quot;);
        root.add(node1);
        root.add(node2);
        root.add(node3);
        Component node21 = new Leaf(&quot;21&quot;);
        Component node22 = new Composite(&quot;22&quot;);
        node2.add(node21);
        node2.add(node22);
        Component node221 = new Leaf(&quot;221&quot;);
        node22.add(node221);
        root.print();
    }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;html
Composite:root
--left:1
--Composite:2
----left:21
----Composite:22
------left:221
--left:3
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;jdk-17&quot;&gt;JDK&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;javax.swing.JComponent#add(Component)&lt;/li&gt;
  &lt;li&gt;java.awt.Container#add(Component)&lt;/li&gt;
  &lt;li&gt;java.util.Map#putAll(Map)&lt;/li&gt;
  &lt;li&gt;java.util.List#addAll(Collection)&lt;/li&gt;
  &lt;li&gt;java.util.Set#addAll(Collection)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;decorator&quot;&gt;4. 装饰（Decorator）&lt;/h2&gt;

&lt;h3 id=&quot;intent-21&quot;&gt;Intent&lt;/h3&gt;

&lt;p&gt;为对象动态添加功能。&lt;/p&gt;

&lt;h3 id=&quot;class-diagram-21&quot;&gt;Class Diagram&lt;/h3&gt;

&lt;p&gt;装饰者（Decorator）和具体组件（ConcreteComponent）都继承自组件（Component），具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/137c593d-0a9e-47b8-a9e6-b71f540b82dd.png&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;implementation-21&quot;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;设计不同种类的饮料，饮料可以添加配料，比如可以添加牛奶，并且支持动态添加新配料。每增加一种配料，该饮料的价格就会增加，要求计算一种饮料的价格。&lt;/p&gt;

&lt;p&gt;下图表示在 DarkRoast 饮料上新增新添加 Mocha 配料，之后又添加了 Whip 配料。DarkRoast 被 Mocha 包裹，Mocha 又被 Whip 包裹。它们都继承自相同父类，都有 cost() 方法，外层类的 cost() 方法调用了内层类的 cost() 方法。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/c9cfd600-bc91-4f3a-9f99-b42f88a5bb24.jpg&quot; width=&quot;600&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public interface Beverage {
    double cost();
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public class DarkRoast implements Beverage {
    @Override
    public double cost() {
        return 1;
    }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public class HouseBlend implements Beverage {
    @Override
    public double cost() {
        return 1;
    }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public abstract class CondimentDecorator implements Beverage {
    protected Beverage beverage;
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;```java
public class Milk extends CondimentDecorator {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public Milk(Beverage beverage) {
    this.beverage = beverage;
}

@Override
public double cost() {
    return 1 + beverage.cost();
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class Mocha extends CondimentDecorator {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public Mocha(Beverage beverage) {
    this.beverage = beverage;
}

@Override
public double cost() {
    return 1 + beverage.cost();
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class Client {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main(String[] args) {
    Beverage beverage = new HouseBlend();
    beverage = new Mocha(beverage);
    beverage = new Milk(beverage);
    System.out.println(beverage.cost());
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;html
3.0
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-11&quot;&gt;设计原则&lt;/h3&gt;

&lt;p&gt;类应该对扩展开放，对修改关闭：也就是添加新功能时不需要修改代码。饮料可以动态添加新的配料，而不需要去修改饮料的代码。&lt;/p&gt;

&lt;p&gt;不可能把所有的类设计成都满足这一原则，应当把该原则应用于最有可能发生改变的地方。&lt;/p&gt;

&lt;h3 id=&quot;jdk-18&quot;&gt;JDK&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;java.io.BufferedInputStream(InputStream)&lt;/li&gt;
  &lt;li&gt;java.io.DataInputStream(InputStream)&lt;/li&gt;
  &lt;li&gt;java.io.BufferedOutputStream(OutputStream)&lt;/li&gt;
  &lt;li&gt;java.util.zip.ZipOutputStream(OutputStream)&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;java.util.Collections#checked[List&lt;/td&gt;
          &lt;td&gt;Map&lt;/td&gt;
          &lt;td&gt;Set&lt;/td&gt;
          &lt;td&gt;SortedSet&lt;/td&gt;
          &lt;td&gt;SortedMap]()&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;facade&quot;&gt;5. 外观（Facade）&lt;/h2&gt;

&lt;h3 id=&quot;intent-22&quot;&gt;Intent&lt;/h3&gt;

&lt;p&gt;提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。&lt;/p&gt;

&lt;h3 id=&quot;class-diagram-22&quot;&gt;Class Diagram&lt;/h3&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/f9978fa6-9f49-4a0f-8540-02d269ac448f.png&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;implementation-22&quot;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;观看电影需要操作很多电器，使用外观模式实现一键看电影功能。&lt;/p&gt;

&lt;p&gt;```java
public class SubSystem {
    public void turnOnTV() {
        System.out.println(“turnOnTV()”);
    }&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void setCD(String cd) {
    System.out.println(&quot;setCD( &quot; + cd + &quot; )&quot;);
}

public void startWatching(){
    System.out.println(&quot;startWatching()&quot;);
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class Facade {
    private SubSystem subSystem = new SubSystem();&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void watchMovie() {
    subSystem.turnOnTV();
    subSystem.setCD(&quot;a movie&quot;);
    subSystem.startWatching();
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public class Client {
    public static void main(String[] args) {
        Facade facade = new Facade();
        facade.watchMovie();
    }
}
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-12&quot;&gt;设计原则&lt;/h3&gt;

&lt;p&gt;最少知识原则：只和你的密友谈话。也就是说客户对象所需要交互的对象应当尽可能少。&lt;/p&gt;

&lt;h2 id=&quot;flyweight&quot;&gt;6. 享元（Flyweight）&lt;/h2&gt;

&lt;h3 id=&quot;intent-23&quot;&gt;Intent&lt;/h3&gt;

&lt;p&gt;利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。&lt;/p&gt;

&lt;h3 id=&quot;class-diagram-23&quot;&gt;Class Diagram&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Flyweight：享元对象&lt;/li&gt;
  &lt;li&gt;IntrinsicState：内部状态，享元对象共享内部状态&lt;/li&gt;
  &lt;li&gt;ExtrinsicState：外部状态，每个享元对象的外部状态不同&lt;/li&gt;
&lt;/ul&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/d52270b4-9097-4667-9f18-f405fc661c99.png&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;implementation-23&quot;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public interface Flyweight {
    void doOperation(String extrinsicState);
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;```java
public class ConcreteFlyweight implements Flyweight {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private String intrinsicState;

public ConcreteFlyweight(String intrinsicState) {
    this.intrinsicState = intrinsicState;
}

@Override
public void doOperation(String extrinsicState) {
    System.out.println(&quot;Object address: &quot; + System.identityHashCode(this));
    System.out.println(&quot;IntrinsicState: &quot; + intrinsicState);
    System.out.println(&quot;ExtrinsicState: &quot; + extrinsicState);
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class FlyweightFactory {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private HashMap&amp;lt;String, Flyweight&amp;gt; flyweights = new HashMap&amp;lt;&amp;gt;();

Flyweight getFlyweight(String intrinsicState) {
    if (!flyweights.containsKey(intrinsicState)) {
        Flyweight flyweight = new ConcreteFlyweight(intrinsicState);
        flyweights.put(intrinsicState, flyweight);
    }
    return flyweights.get(intrinsicState);
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class Client {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main(String[] args) {
    FlyweightFactory factory = new FlyweightFactory();
    Flyweight flyweight1 = factory.getFlyweight(&quot;aa&quot;);
    Flyweight flyweight2 = factory.getFlyweight(&quot;aa&quot;);
    flyweight1.doOperation(&quot;x&quot;);
    flyweight2.doOperation(&quot;y&quot;);
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;html
Object address: 1163157884
IntrinsicState: aa
ExtrinsicState: x
Object address: 1163157884
IntrinsicState: aa
ExtrinsicState: y
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;jdk-19&quot;&gt;JDK&lt;/h3&gt;

&lt;p&gt;Java 利用缓存来加速大量小对象的访问时间。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;java.lang.Integer#valueOf(int)&lt;/li&gt;
  &lt;li&gt;java.lang.Boolean#valueOf(boolean)&lt;/li&gt;
  &lt;li&gt;java.lang.Byte#valueOf(byte)&lt;/li&gt;
  &lt;li&gt;java.lang.Character#valueOf(char)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;proxy&quot;&gt;7. 代理（Proxy）&lt;/h2&gt;

&lt;h3 id=&quot;intent-24&quot;&gt;Intent&lt;/h3&gt;

&lt;p&gt;控制对其它对象的访问。&lt;/p&gt;

&lt;h3 id=&quot;class-diagram-24&quot;&gt;Class Diagram&lt;/h3&gt;

&lt;p&gt;代理有以下四类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;远程代理（Remote Proxy）：控制对远程对象（不同地址空间）的访问，它负责将请求及其参数进行编码，并向不同地址空间中的对象发送已经编码的请求。&lt;/li&gt;
  &lt;li&gt;虚拟代理（Virtual Proxy）：根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问，例如在网站加载一个很大图片时，不能马上完成，可以用虚拟代理缓存图片的大小信息，然后生成一张临时图片代替原始图片。&lt;/li&gt;
  &lt;li&gt;保护代理（Protection Proxy）：按权限控制对象的访问，它负责检查调用者是否具有实现一个请求所必须的访问权限。&lt;/li&gt;
  &lt;li&gt;智能代理（Smart Reference）：取代了简单的指针，它在访问对象时执行一些附加操作：记录对象的引用次数；当第一次引用一个对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其它对象不能改变它。&lt;/li&gt;
&lt;/ul&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/a6c20f60-5eba-427d-9413-352ada4b40fe.png&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;implementation-24&quot;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;以下是一个虚拟代理的实现，模拟了图片延迟加载的情况下使用与图片大小相等的临时内容去替换原始图片，直到图片加载完成才将图片显示出来。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
public interface Image {
    void showImage();
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;```java
public class HighResolutionImage implements Image {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private URL imageURL;
private long startTime;
private int height;
private int width;

public int getHeight() {
    return height;
}

public int getWidth() {
    return width;
}

public HighResolutionImage(URL imageURL) {
    this.imageURL = imageURL;
    this.startTime = System.currentTimeMillis();
    this.width = 600;
    this.height = 600;
}

public boolean isLoad() {
    // 模拟图片加载，延迟 3s 加载完成
    long endTime = System.currentTimeMillis();
    return endTime - startTime &amp;gt; 3000;
}

@Override
public void showImage() {
    System.out.println(&quot;Real Image: &quot; + imageURL);
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class ImageProxy implements Image {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private HighResolutionImage highResolutionImage;

public ImageProxy(HighResolutionImage highResolutionImage) {
    this.highResolutionImage = highResolutionImage;
}

@Override
public void showImage() {
    while (!highResolutionImage.isLoad()) {
        try {
            System.out.println(&quot;Temp Image: &quot; + highResolutionImage.getWidth() + &quot; &quot; + highResolutionImage.getHeight());
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    highResolutionImage.showImage();
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```java
public class ImageViewer {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main(String[] args) throws Exception {
    String image = &quot;http://image.jpg&quot;;
    URL url = new URL(image);
    HighResolutionImage highResolutionImage = new HighResolutionImage(url);
    ImageProxy imageProxy = new ImageProxy(highResolutionImage);
    imageProxy.showImage();
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;jdk-20&quot;&gt;JDK&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;java.lang.reflect.Proxy&lt;/li&gt;
  &lt;li&gt;RMI&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section-13&quot;&gt;参考资料&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;弗里曼. Head First 设计模式 [M]. 中国电力出版社, 2007.&lt;/li&gt;
  &lt;li&gt;Gamma E. 设计模式: 可复用面向对象软件的基础 [M]. 机械工业出版社, 2007.&lt;/li&gt;
  &lt;li&gt;Bloch J. Effective java[M]. Addison-Wesley Professional, 2017.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.oodesign.com/&quot;&gt;Design Patterns&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://java-design-patterns.com/&quot;&gt;Design patterns implemented in Java&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.programering.com/a/MTNxAzMwATY.html&quot;&gt;The breakdown of design patterns in JDK&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 21 Feb 2019 08:30:00 +0800</pubDate>
        <link>https://bbel.ink/2019/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
        <guid isPermaLink="true">https://bbel.ink/2019/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
        
        <category>设计模式</category>
        
        
      </item>
    
      <item>
        <title>集群</title>
        <description>&lt;!-- GFM-TOC --&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#一负载均衡&quot;&gt;一、负载均衡&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#负载均衡算法&quot;&gt;负载均衡算法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#转发实现&quot;&gt;转发实现&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#二集群下的-session-管理&quot;&gt;二、集群下的 Session 管理&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#sticky-session&quot;&gt;Sticky Session&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#session-replication&quot;&gt;Session Replication&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#session-server&quot;&gt;Session Server&lt;/a&gt;
&lt;!-- GFM-TOC --&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section&quot;&gt;一、负载均衡&lt;/h1&gt;

&lt;p&gt;集群中的应用服务器（节点）通常被设计成无状态，用户可以请求任何一个节点。&lt;/p&gt;

&lt;p&gt;负载均衡器会根据集群中每个节点的负载情况，将用户请求转发到合适的节点上。&lt;/p&gt;

&lt;p&gt;负载均衡器可以用来实现高可用以及伸缩性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;高可用：当某个节点故障时，负载均衡器会将用户请求转发到另外的节点上，从而保证所有服务持续可用；&lt;/li&gt;
  &lt;li&gt;伸缩性：根据系统整体负载情况，可以很容易地添加或移除节点。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;负载均衡器运行过程包含两个部分：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;根据负载均衡算法得到转发的节点；&lt;/li&gt;
  &lt;li&gt;进行转发。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;负载均衡算法&lt;/h2&gt;

&lt;h3 id=&quot;round-robin&quot;&gt;1. 轮询（Round Robin）&lt;/h3&gt;

&lt;p&gt;轮询算法把每个请求轮流发送到每个服务器上。&lt;/p&gt;

&lt;p&gt;下图中，一共有 6 个客户端产生了 6 个请求，这 6 个请求按 (1, 2, 3, 4, 5, 6) 的顺序发送。(1, 3, 5) 的请求会被发送到服务器 1，(2, 4, 6) 的请求会被发送到服务器 2。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/2766d04f-7dad-42e4-99d1-60682c9d5c61.jpg&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;该算法比较适合每个服务器的性能差不多的场景，如果有性能存在差异的情况下，那么性能较差的服务器可能无法承担过大的负载（下图的 Server 2）。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/f7ecbb8d-bb8b-4d45-a3b7-f49425d6d83d.jpg&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;weighted-round-robbin&quot;&gt;2. 加权轮询（Weighted Round Robbin）&lt;/h3&gt;

&lt;p&gt;加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值，性能高的服务器分配更高的权值。&lt;/p&gt;

&lt;p&gt;例如下图中，服务器 1 被赋予的权值为 5，服务器 2 被赋予的权值为 1，那么 (1, 2, 3, 4, 5) 请求会被发送到服务器 1，(6) 请求会被发送到服务器 2。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/211c60d4-75ca-4acd-8a4f-171458ed58b4.jpg&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;least-connections&quot;&gt;3. 最少连接（least Connections）&lt;/h3&gt;

&lt;p&gt;由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数过大，而另一台服务器的连接过小，造成负载不均衡。&lt;/p&gt;

&lt;p&gt;例如下图中，(1, 3, 5) 请求会被发送到服务器 1，但是 (1, 3) 很快就断开连接，此时只有 (5) 请求连接服务器 1；(2, 4, 6) 请求被发送到服务器 2，只有 (2) 的连接断开，此时 (6, 4) 请求连接服务器 2。该系统继续运行时，服务器 2 会承担过大的负载。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/3b0d1aa8-d0e0-46c2-8fd1-736bf08a11aa.jpg&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;最少连接算法就是将请求发送给当前最少连接数的服务器上。&lt;/p&gt;

&lt;p&gt;例如下图中，服务器 1 当前连接数最小，那么新到来的请求 6 就会被发送到服务器 1 上。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/1f4a7f10-52b2-4bd7-a67d-a9581d66dc62.jpg&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;weighted-least-connection&quot;&gt;4. 加权最少连接（Weighted Least Connection）&lt;/h3&gt;

&lt;p&gt;在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/44edefb7-4b58-4519-b8ee-4aca01697b78.jpg&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;random&quot;&gt;5. 随机算法（Random）&lt;/h3&gt;

&lt;p&gt;把请求随机发送到服务器上。&lt;/p&gt;

&lt;p&gt;和轮询算法类似，该算法比较适合服务器性能差不多的场景。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/0ee0f61b-c782-441e-bf34-665650198ae0.jpg&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;ip-hash&quot;&gt;6. 源地址哈希法 (IP Hash)&lt;/h3&gt;

&lt;p&gt;源地址哈希通过对客户端 IP 计算哈希值之后，再对服务器数量取模得到目标服务器的序号。&lt;/p&gt;

&lt;p&gt;可以保证同一 IP 的客户端的请求会转发到同一台服务器上，用来实现会话粘滞（Sticky Session）&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/2018040302.jpg&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;转发实现&lt;/h2&gt;

&lt;h3 id=&quot;http-&quot;&gt;1. HTTP 重定向&lt;/h3&gt;

&lt;p&gt;HTTP 重定向负载均衡服务器使用某种负载均衡算法计算得到服务器的 IP 地址之后，将该地址写入 HTTP 重定向报文中，状态码为 302。客户端收到重定向报文之后，需要重新向服务器发起请求。&lt;/p&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;需要两次请求，因此访问延迟比较高；&lt;/li&gt;
  &lt;li&gt;HTTP 负载均衡器处理能力有限，会限制集群的规模。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;该负载均衡转发的缺点比较明显，实际场景中很少使用它。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/c5f611f0-fd5c-4158-9003-278141136e6e.jpg&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;dns-&quot;&gt;2. DNS 域名解析&lt;/h3&gt;

&lt;p&gt;在 DNS 解析域名的同时使用负载均衡算法计算服务器 IP 地址。&lt;/p&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DNS 能够根据地理位置进行域名解析，返回离用户最近的服务器 IP 地址。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;由于 DNS 具有多级结构，每一级的域名记录都可能被缓存，当下线一台服务器需要修改 DNS 记录时，需要过很长一段时间才能生效。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;大型网站基本使用了 DNS 做为第一级负载均衡手段，然后在内部使用其它方式做第二级负载均衡。也就是说，域名解析的结果为内部的负载均衡服务器 IP 地址。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/76a25fc8-a579-4d7c-974b-7640b57fbf39.jpg&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;3. 反向代理服务器&lt;/h3&gt;

&lt;p&gt;反向代理服务器位于源服务器前面，用户的请求需要先经过反向代理服务器才能到达源服务器。反向代理可以用来进行缓存、日志记录等，同时也可以用来做为负载均衡服务器。&lt;/p&gt;

&lt;p&gt;在这种负载均衡转发方式下，客户端不直接请求源服务器，因此源服务器不需要外部 IP 地址，而反向代理需要配置内部和外部两套 IP 地址。&lt;/p&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;与其它功能集成在一起，部署简单。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;所有请求和响应都需要经过反向代理服务器，它可能会成为性能瓶颈。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;4. 网络层&lt;/h3&gt;

&lt;p&gt;在操作系统内核进程获取网络数据包，根据负载均衡算法计算源服务器的 IP 地址，并修改请求数据包的目的 IP 地址，最后进行转发。&lt;/p&gt;

&lt;p&gt;源服务器返回的响应也需要经过负载均衡服务器，通常是让负载均衡服务器同时作为集群的网关服务器来实现。&lt;/p&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在内核进程中进行处理，性能比较高。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;和反向代理一样，所有的请求和响应都经过负载均衡服务器，会成为性能瓶颈。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;5. 链路层&lt;/h3&gt;

&lt;p&gt;在链路层根据负载均衡算法计算源服务器的 MAC 地址，并修改请求数据包的目的 MAC 地址，并进行转发。&lt;/p&gt;

&lt;p&gt;通过配置源服务器的虚拟 IP 地址和负载均衡服务器的 IP 地址一致，从而不需要修改 IP 地址就可以进行转发。也正因为 IP 地址一样，所以源服务器的响应不需要转发回负载均衡服务器，可以直接转发给客户端，避免了负载均衡服务器的成为瓶颈。&lt;/p&gt;

&lt;p&gt;这是一种三角传输模式，被称为直接路由。对于提供下载和视频服务的网站来说，直接路由避免了大量的网络传输数据经过负载均衡服务器。&lt;/p&gt;

&lt;p&gt;这是目前大型网站使用最广负载均衡转发方式，在 Linux 平台可以使用的负载均衡服务器为 LVS（Linux Virtual Server）。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.jscape.com/blog/load-balancing-algorithms&quot;&gt;Comparing Load Balancing Algorithms&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://slideplayer.com/slide/6599069/#&quot;&gt;Redirection and Load Balancing&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;session-&quot;&gt;二、集群下的 Session 管理&lt;/h1&gt;

&lt;p&gt;一个用户的 Session 信息如果存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器，由于服务器没有用户的 Session 信息，那么该用户就需要重新进行登录等操作。&lt;/p&gt;

&lt;h2 id=&quot;sticky-session&quot;&gt;Sticky Session&lt;/h2&gt;

&lt;p&gt;需要配置负载均衡器，使得一个用户的所有请求都路由到同一个服务器，这样就可以把用户的 Session 存放在该服务器中。&lt;/p&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当服务器宕机时，将丢失该服务器上的所有 Session。&lt;/li&gt;
&lt;/ul&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/MultiNode-StickySessions.jpg&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;session-replication&quot;&gt;Session Replication&lt;/h2&gt;

&lt;p&gt;在服务器之间进行 Session 同步操作，每个服务器都有所有用户的 Session 信息，因此用户可以向任何一个服务器进行请求。&lt;/p&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;占用过多内存；&lt;/li&gt;
  &lt;li&gt;同步过程占用网络带宽以及服务器处理器时间。&lt;/li&gt;
&lt;/ul&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/MultiNode-SessionReplication.jpg&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;session-server&quot;&gt;Session Server&lt;/h2&gt;

&lt;p&gt;使用一个单独的服务器存储 Session 数据，可以使用传统的 MySQL，也使用 Redis 或者 Memcached 这种内存型数据库。&lt;/p&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;为了使得大型网站具有伸缩性，集群中的应用服务器通常需要保持无状态，那么应用服务器不能存储用户的会话信息。Session Server 将用户的会话信息单独进行存储，从而保证了应用服务器的无状态。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;需要去实现存取 Session 的代码。&lt;/li&gt;
&lt;/ul&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/MultiNode-SpringSession.jpg&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://sivalabs.in/2018/02/session-management-using-spring-session-jdbc-datastore/&quot;&gt;Session Management using Spring Session with JDBC DataStore&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 17 Feb 2019 08:30:00 +0800</pubDate>
        <link>https://bbel.ink/2019/02/%E9%9B%86%E7%BE%A4/</link>
        <guid isPermaLink="true">https://bbel.ink/2019/02/%E9%9B%86%E7%BE%A4/</guid>
        
        <category>集群</category>
        
        
      </item>
    
      <item>
        <title>代码风格规范</title>
        <description>&lt;!-- GFM-TOC --&gt;
&lt;!-- GFM-TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/twitter/commons/blob/master/src/java/com/twitter/common/styleguide.md&quot;&gt;Twitter Java Style Guide&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://google.github.io/styleguide/javaguide.html&quot;&gt;Google Java Style Guide&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/alibaba/p3c/blob/master/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E8%AF%A6%E5%B0%BD%E7%89%88%EF%BC%89.pdf&quot;&gt;阿里巴巴Java开发手册&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 15 Feb 2019 08:30:00 +0800</pubDate>
        <link>https://bbel.ink/2019/02/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83/</link>
        <guid isPermaLink="true">https://bbel.ink/2019/02/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83/</guid>
        
        <category>代码风格规范</category>
        
        
      </item>
    
      <item>
        <title>面向对象思想</title>
        <description>&lt;!-- GFM-TOC --&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#一三大特性&quot;&gt;一、三大特性&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#封装&quot;&gt;封装&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#继承&quot;&gt;继承&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#多态&quot;&gt;多态&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#二类图&quot;&gt;二、类图&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#泛化关系-generalization&quot;&gt;泛化关系 (Generalization)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#实现关系-realization&quot;&gt;实现关系 (Realization)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#聚合关系-aggregation&quot;&gt;聚合关系 (Aggregation)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#组合关系-composition&quot;&gt;组合关系 (Composition)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#关联关系-association&quot;&gt;关联关系 (Association)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#依赖关系-dependency&quot;&gt;依赖关系 (Dependency)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#三设计原则&quot;&gt;三、设计原则&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#solid&quot;&gt;S.O.L.I.D&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#其他常见原则&quot;&gt;其他常见原则&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#参考资料&quot;&gt;参考资料&lt;/a&gt;
&lt;!-- GFM-TOC --&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section&quot;&gt;一、三大特性&lt;/h1&gt;

&lt;h2 id=&quot;section-1&quot;&gt;封装&lt;/h2&gt;

&lt;p&gt;利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。&lt;/p&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;减少耦合：可以独立地开发、测试、优化、使用、理解和修改&lt;/li&gt;
  &lt;li&gt;减轻维护的负担：可以更容易被程序员理解，并且在调试的时候可以不影响其他模块&lt;/li&gt;
  &lt;li&gt;有效地调节性能：可以通过剖析确定哪些模块影响了系统的性能&lt;/li&gt;
  &lt;li&gt;提高软件的可重用性&lt;/li&gt;
  &lt;li&gt;降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。&lt;/p&gt;

&lt;p&gt;注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。&lt;/p&gt;

&lt;p&gt;```java
public class Person {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private String name;
private int gender;
private int age;

public String getName() {
    return name;
}

public String getGender() {
    return gender == 0 ? &quot;man&quot; : &quot;woman&quot;;
}

public void work() {
    if (18 &amp;lt;= age &amp;amp;&amp;amp; age &amp;lt;= 50) {
        System.out.println(name + &quot; is working very hard!&quot;);
    } else {
        System.out.println(name + &quot; can&#39;t work any more!&quot;);
    }
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-2&quot;&gt;继承&lt;/h2&gt;

&lt;p&gt;继承实现了  &lt;strong&gt;IS-A&lt;/strong&gt;  关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。&lt;/p&gt;

&lt;p&gt;继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。&lt;/p&gt;

&lt;p&gt;Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为  &lt;strong&gt;向上转型&lt;/strong&gt; 。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java
Animal animal = new Cat();
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;多态&lt;/h2&gt;

&lt;p&gt;多态分为编译时多态和运行时多态：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;编译时多态主要指方法的重载&lt;/li&gt;
  &lt;li&gt;运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;运行时多态有三个条件：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;继承&lt;/li&gt;
  &lt;li&gt;覆盖（重写）&lt;/li&gt;
  &lt;li&gt;向上转型&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。&lt;/p&gt;

&lt;p&gt;```java
public class Instrument {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void play() {
    System.out.println(&quot;Instument is playing...&quot;);
} }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;public class Wind extends Instrument {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void play() {
    System.out.println(&quot;Wind is playing...&quot;);
} }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;public class Percussion extends Instrument {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void play() {
    System.out.println(&quot;Percussion is playing...&quot;);
} }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;public class Music {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main(String[] args) {
    List&amp;lt;Instrument&amp;gt; instruments = new ArrayList&amp;lt;&amp;gt;();
    instruments.add(new Wind());
    instruments.add(new Percussion());
    for(Instrument instrument : instruments) {
        instrument.play();
    }
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;section-4&quot;&gt;二、类图&lt;/h1&gt;

&lt;p&gt;以下类图使用 &lt;a href=&quot;https://www.planttext.com/&quot;&gt;PlantUML&lt;/a&gt; 绘制，更多语法及使用请参考：http://plantuml.com/ 。&lt;/p&gt;

&lt;h2 id=&quot;generalization&quot;&gt;泛化关系 (Generalization)&lt;/h2&gt;

&lt;p&gt;用来描述继承关系，在 Java 中使用 extends 关键字。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/SoWkIImgAStDuU8goIp9ILLmJyrBBKh.png&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;```text
@startuml&lt;/p&gt;

&lt;p&gt;title Generalization&lt;/p&gt;

&lt;p&gt;class Vihical
class Car
class Trunck&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Vihical &amp;lt;&lt;/td&gt;
      &lt;td&gt;– Car&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Vihical &amp;lt;&lt;/td&gt;
      &lt;td&gt;– Trunck&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;@enduml
```&lt;/p&gt;

&lt;h2 id=&quot;realization&quot;&gt;实现关系 (Realization)&lt;/h2&gt;

&lt;p&gt;用来实现一个接口，在 Java 中使用 implements 关键字。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/SoWkIImgAStDuU8goIp9ILK8IatCoQn.png&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;```text
@startuml&lt;/p&gt;

&lt;p&gt;title Realization&lt;/p&gt;

&lt;p&gt;interface MoveBehavior
class Fly
class Run&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;MoveBehavior &amp;lt;&lt;/td&gt;
      &lt;td&gt;.. Fly&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MoveBehavior &amp;lt;&lt;/td&gt;
      &lt;td&gt;.. Run&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;@enduml
```&lt;/p&gt;

&lt;h2 id=&quot;aggregation&quot;&gt;聚合关系 (Aggregation)&lt;/h2&gt;

&lt;p&gt;表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/SoWkIImgAStDuU8goIp9ILLmJ4ylIar.png&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;```text
@startuml&lt;/p&gt;

&lt;p&gt;title Aggregation&lt;/p&gt;

&lt;p&gt;class Computer
class Keyboard
class Mouse
class Screen&lt;/p&gt;

&lt;p&gt;Computer o– Keyboard
Computer o– Mouse
Computer o– Screen&lt;/p&gt;

&lt;p&gt;@enduml
```&lt;/p&gt;

&lt;h2 id=&quot;composition&quot;&gt;组合关系 (Composition)&lt;/h2&gt;

&lt;p&gt;和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/SoWkIImgAStDuU8goIp9ILLmpiyjo2_.png&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;```text
@startuml&lt;/p&gt;

&lt;p&gt;title Composition&lt;/p&gt;

&lt;p&gt;class Company
class DepartmentA
class DepartmentB&lt;/p&gt;

&lt;p&gt;Company *– DepartmentA
Company *– DepartmentB&lt;/p&gt;

&lt;p&gt;@enduml
```&lt;/p&gt;

&lt;h2 id=&quot;association&quot;&gt;关联关系 (Association)&lt;/h2&gt;

&lt;p&gt;表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/SoWkIImgAStDuU8goIp9ILLmB2xEJyv.png&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;```text
@startuml&lt;/p&gt;

&lt;p&gt;title Association&lt;/p&gt;

&lt;p&gt;class School
class Student&lt;/p&gt;

&lt;p&gt;School “1” - “n” Student&lt;/p&gt;

&lt;p&gt;@enduml
```&lt;/p&gt;

&lt;h2 id=&quot;dependency&quot;&gt;依赖关系 (Dependency)&lt;/h2&gt;

&lt;p&gt;和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A 类是 B 类方法的局部变量；&lt;/li&gt;
  &lt;li&gt;A 类是 B 类方法当中的一个参数；&lt;/li&gt;
  &lt;li&gt;A 类向 B 类发送消息，从而影响 B 类发生变化。&lt;/li&gt;
&lt;/ul&gt;

&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/LOun2W9134NxVugmbJPp15d4LalxC4O.png&quot; /&gt; &lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;```text
@startuml&lt;/p&gt;

&lt;p&gt;title Dependency&lt;/p&gt;

&lt;p&gt;class Vihicle {
    move(MoveBehavior)
}&lt;/p&gt;

&lt;p&gt;interface MoveBehavior {
    move()
}&lt;/p&gt;

&lt;p&gt;note “MoveBehavior.move()” as N&lt;/p&gt;

&lt;p&gt;Vihicle ..&amp;gt; MoveBehavior&lt;/p&gt;

&lt;p&gt;Vihicle .. N&lt;/p&gt;

&lt;p&gt;@enduml
```&lt;/p&gt;

&lt;h1 id=&quot;section-5&quot;&gt;三、设计原则&lt;/h1&gt;

&lt;h2 id=&quot;solid&quot;&gt;S.O.L.I.D&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;简写&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;全拼&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;中文翻译&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;SRP&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;The Single Responsibility Principle&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;单一责任原则&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;OCP&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;The Open Closed Principle&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;开放封闭原则&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;LSP&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;The Liskov Substitution Principle&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;里氏替换原则&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ISP&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;The Interface Segregation Principle&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;接口分离原则&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;DIP&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;The Dependency Inversion Principle&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;依赖倒置原则&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-6&quot;&gt;1. 单一责任原则&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;修改一个类的原因应该只有一个。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。&lt;/p&gt;

&lt;p&gt;如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;2. 开放封闭原则&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;类应该对扩展开放，对修改关闭。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。&lt;/p&gt;

&lt;p&gt;符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;3. 里氏替换原则&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;子类对象必须能够替换掉所有父类对象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。&lt;/p&gt;

&lt;p&gt;如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;4. 接口分离原则&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;不应该强迫客户依赖于它们不用的方法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因此使用多个专门的接口比使用单一的总接口要好。&lt;/p&gt;

&lt;h3 id=&quot;section-10&quot;&gt;5. 依赖倒置原则&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;高层模块不应该依赖于低层模块，二者都应该依赖于抽象；&amp;lt;/br&amp;gt;抽象不应该依赖于细节，细节应该依赖于抽象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。&lt;/p&gt;

&lt;p&gt;依赖于抽象意味着：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;任何变量都不应该持有一个指向具体类的指针或者引用；&lt;/li&gt;
  &lt;li&gt;任何类都不应该从具体类派生；&lt;/li&gt;
  &lt;li&gt;任何方法都不应该覆写它的任何基类中的已经实现的方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-11&quot;&gt;其他常见原则&lt;/h2&gt;

&lt;p&gt;除了上述的经典原则，在实际开发中还有下面这些常见的设计原则。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;简写&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;全拼&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;中文翻译&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;LOD&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;The Law of Demeter&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;迪米特法则&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;CRP&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;The Composite Reuse Principle&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;合成复用原则&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;CCP&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;The Common Closure Principle&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;共同封闭原则&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;SAP&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;The Stable Abstractions Principle&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;稳定抽象原则&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;SDP&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;The Stable Dependencies Principle&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;稳定依赖原则&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-12&quot;&gt;1. 迪米特法则&lt;/h3&gt;

&lt;p&gt;迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。&lt;/p&gt;

&lt;h3 id=&quot;section-13&quot;&gt;2. 合成复用原则&lt;/h3&gt;

&lt;p&gt;尽量使用对象组合，而不是通过继承来达到复用的目的。&lt;/p&gt;

&lt;h3 id=&quot;section-14&quot;&gt;3. 共同封闭原则&lt;/h3&gt;

&lt;p&gt;一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。&lt;/p&gt;

&lt;h3 id=&quot;section-15&quot;&gt;4. 稳定抽象原则&lt;/h3&gt;

&lt;p&gt;最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比。&lt;/p&gt;

&lt;h3 id=&quot;section-16&quot;&gt;5. 稳定依赖原则&lt;/h3&gt;

&lt;p&gt;包之间的依赖关系都应该是稳定方向依赖的，包要依赖的包要比自己更具有稳定性。&lt;/p&gt;

&lt;h1 id=&quot;section-17&quot;&gt;参考资料&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Java 编程思想&lt;/li&gt;
  &lt;li&gt;敏捷软件开发：原则、模式与实践&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/shanyou/archive/2009/09/21/1570716.html&quot;&gt;面向对象设计的 SOLID 原则&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html#generalization&quot;&gt;看懂 UML 类图和时序图&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/wolf-sun/p/UML-Sequence-diagram.html&quot;&gt;UML 系列——时序图（顺序图）sequence diagram&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/jianyuerensheng/article/details/51602015&quot;&gt;面向对象编程三大特性 —— 封装、继承、多态&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 13 Feb 2019 08:30:00 +0800</pubDate>
        <link>https://bbel.ink/2019/02/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3/</link>
        <guid isPermaLink="true">https://bbel.ink/2019/02/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3/</guid>
        
        <category>java</category>
        
        
      </item>
    
      <item>
        <title>你的深度思考能力，是如何一步步被毁掉的？</title>
        <description>&lt;p&gt;前阵子，喜茶风靡全国的时候，有一次，经过一家商场，看到一家新开的喜茶，门口毫不意外地排着几十米的长队。&lt;/p&gt;

&lt;p&gt;排队的人中，男女老少均有，居然还有不少穿着正装、提着公文包的白领。有些明显赶时间，频频看表，左右张望，在原地不耐烦地跺脚。
好奇心起，我观察了一遍整个队伍，想知道他们怎么消磨时间。
你猜我看到了什么？&lt;/p&gt;

&lt;p&gt;90%的人，在玩王者荣耀。&lt;/p&gt;

&lt;p&gt;是的，这两个当下最热的词汇，就这样结合在一起，毫不违和。&lt;/p&gt;

&lt;p&gt;尽管「Don’t judge」是我的信条，但当时还是不可抑制地产生了这样的疑问：&lt;/p&gt;

&lt;p&gt;这些人为什么这么闲？&lt;/p&gt;

&lt;p&gt;为什么他们愿意把大把的时间，耗费在这些事情上面？&lt;/p&gt;

&lt;p&gt;从心理学的角度，我可以毫不费力地列举出十几条「为什么会有人愿意排队买喜茶」的机制。但设身处地，真的让我排几个小时队，去买一杯奶茶，我还是会觉得，这实在是太匪夷所思了。&lt;/p&gt;

&lt;p&gt;同样，作为一个体验过纯文字MUD的老玩家（暴露年龄），我也完全理解游戏背后的一切机制。但是，每天把几个小时的时间耗费在游戏上 —— 这仍然会让我觉得：太奢侈了。&lt;/p&gt;

&lt;p&gt;有这么多时间，看看书，不是更好吗？&lt;/p&gt;

&lt;p&gt;1995年9月27日至10月1日，美国旧金山举行过一次会议，集合了全球500多位政治、经济精英，包括撒切尔、老布什、各大顶尖企业的董事长，等等。&lt;/p&gt;

&lt;p&gt;会议的主题是什么呢？如何应对全球化。&lt;/p&gt;

&lt;p&gt;会上，与会者一致认为，全球化会加剧贫富差距，会使财富集中在全球20%的人手上，而另外80%的人被「边缘化」。&lt;/p&gt;

&lt;p&gt;那么，如何化解这80%的人和20%精英之间的冲突？如何消解这80%人口的多余精力和不满情绪，转移他们的注意力？&lt;/p&gt;

&lt;p&gt;当时的美国高级智囊布热津斯基认为，唯一的方法，是给这80%的人口，塞上一个「奶嘴」。让他们安于为他们量身订造的娱乐信息中，慢慢丧失热情、抗争欲望和思考的能力。&lt;/p&gt;

&lt;p&gt;他说：「公众们将会在不久的将来，失去自主思考和判断的能力。最终他们会期望媒体为他们进行思考，并作出判断。」&lt;/p&gt;

&lt;p&gt;这就是闻名遐迩的「Tittytainment」战略，由Titty（奶嘴）与 Entertainment（娱乐）合成，中文译为「奶头乐」（有点三俗的译法）。&lt;/p&gt;

&lt;p&gt;「奶头乐」战略，具体是什么呢？&lt;/p&gt;

&lt;p&gt;一，是发展发泄性的产业。具体而言，包括色情业、赌博业，发展暴力型影视剧、游戏，集中报道无休止的口水战、纠纷冲突，等等，让大众将多余的精力发泄出来。&lt;/p&gt;

&lt;p&gt;二，是发展满足性的产业。包括报道连篇累牍的无聊琐事——娱乐圈新闻、明星花边、家长里短，发展廉价品牌，各种小恩小惠的活动，以及偶像剧、综艺等大众化娱乐产业，让大众沉溺于享乐和安逸中，从而丧失上进心和深度思考能力。&lt;/p&gt;

&lt;p&gt;一言以蔽之，那些被边缘化的人，只需要给他们一口饭吃，一份工作，让他们有东西可看，便会沉浸在「快乐」之中，无心挑战现有的统治阶级。&lt;/p&gt;

&lt;p&gt;这个战略成功了吗？&lt;/p&gt;

&lt;p&gt;目前来看，挺成功的。&lt;/p&gt;

&lt;p&gt;是的，我说的就是一切偶像剧、明星、娱乐圈、微博热搜、暴力冲突、情绪煽动、阶级对立、低幼化游戏。&lt;/p&gt;

&lt;p&gt;我们日常的视野中，充斥着这些信息。但这其中，99%的东西，与我们一点关系都没有，对我们也没有哪怕一丁点价值。&lt;/p&gt;

&lt;p&gt;微博热搜，可以买，可以冲，给够营销团队的钱，想上什么就上什么。&lt;/p&gt;

&lt;p&gt;百度新闻，绝大多数是标题党，不是哪个明星出了新戏，就是谁谁又闹了绯闻。&lt;/p&gt;

&lt;p&gt;更别说今日头条之类的资讯平台、和朋友圈里疯传的各种推送了。&lt;/p&gt;

&lt;p&gt;奇葩说第一季刚出来的时候，眼前一亮，毕竟算是一档有价值和内涵的综艺，非常难得。&lt;/p&gt;

&lt;p&gt;但看了几期之后，你会慢慢发现，思辨开始让位于煽情，逻辑永远辩不过故事。&lt;/p&gt;

&lt;p&gt;看实时投票，感受最鲜明的是：观众并不在乎逻辑，并不关心谁说得有理，他们只关心谁说得更声情并茂。通常背景音乐一转，开始变成钢琴独奏，情绪酝酿起来了，票数就开始变化了。&lt;/p&gt;

&lt;p&gt;那群选手里面，我比较欣赏的，是陈铭。&lt;/p&gt;

&lt;p&gt;无论是思考的角度，还是逻辑论证，单单论表现来说，都高出其他人不止一个档次——当然，并不意味着其他人水平不高，很可能只是选择的路线和策略不同而已。&lt;/p&gt;

&lt;p&gt;但节目组苦心孤诣，一定要给陈铭安上「鸡汤王」的标签；每次他起立发言，马薇薇总会扯一句「又开始在世界中心呼唤爱了」—— 如果我是陈铭，我想，我一定不会喜欢这种感受，因为这是一种曲解和侮辱。&lt;/p&gt;

&lt;p&gt;但为什么会这样呢？因为观众只能理解这些。&lt;/p&gt;

&lt;p&gt;最近，知乎在讨论一个话题：如何看待越来越多的大V，靠爆照、编故事、抄袭段子起家，拿到几千、几万的关注？&lt;/p&gt;

&lt;p&gt;有人说得很好：同一个人，爆照回答1000赞，写情感故事1000赞，科普专业知识、还得到编辑推荐和一帮大V点赞的回答，才不到100赞 —— 如果是你，你会怎么选？&lt;/p&gt;

&lt;p&gt;麦克卢汉说过一句话：我们创造了工具，工具反过来塑造我们。&lt;/p&gt;

&lt;p&gt;在这里，也是一样的：我们选择了怎样的媒体，媒体就用怎样的方式塑造我们。&lt;/p&gt;

&lt;p&gt;无独有偶，大前研一在《低智商社会》中提到，日本的新一代，正在逐渐步入「低智商社会」。他们读的书越来越幼稚，对各种谣言丝毫不会思考，很容易遭到媒体的操纵，得过且过、毫无斗志……&lt;/p&gt;

&lt;p&gt;他甚至提到一个事情：&lt;/p&gt;

&lt;p&gt;通过「安保斗争」，日本政府认识到，如果对过激的学生运动放任不管的话，就会导致政府下台，所以政府就从此开始实行「愚民政策」。这其中的代表性举措，就是推行「偏差值教育制度」。&lt;/p&gt;

&lt;p&gt;大前研一这样解释道：&lt;/p&gt;

&lt;p&gt;由于偏差值制度的实行，人的能力被数字化了，所以日本的学生经常会被问到「你的偏差值是多少」这样的问题。&lt;/p&gt;

&lt;p&gt;所以他们在这个时代是不会有危机意识的。因为在他们的意识里，这个社会将来不管发生了什么事，都将由那些「高偏差值」的人来解决。自己用不着去浪费脑细胞，只要按照别人说的去做就可以了。&lt;/p&gt;

&lt;p&gt;他们习惯于在同一班级或者是同一年级组中作比较，然后认为那些高偏差值的人，理所当然地就应该去政府部门工作。同样，能进入媒体工作的人也被认为是高偏差值的人。&lt;/p&gt;

&lt;p&gt;所以，他们认为政府所做的一切决策都是对的，媒体所说的话也全都是可信的。&lt;/p&gt;

&lt;p&gt;日本社会的现状就是这样。人人都把政府和媒体当做自己生活的指南。他们根本就不会去思考和反思。&lt;/p&gt;

&lt;p&gt;这岂非也是另一种层面的「奶头乐」？&lt;/p&gt;

&lt;p&gt;通过阻断你的希望，让你活在别人为你设定好的框架里，停止思考，失去独立的能力，越来越依赖于环境。&lt;/p&gt;

&lt;p&gt;私下里，我跟一帮朋友聊天的时候（嗯，就是大家熟悉的高太爷、曾少贤、孙圈圈……），大家都会说：我们选择了 Hard 模式。&lt;/p&gt;

&lt;p&gt;因为，愿意深入思考，愿意看我们文章的人，本来就是小众。&lt;/p&gt;

&lt;p&gt;大众喜闻乐见的是什么呢？情绪，观点，立场，站队 —— 看文章就是为了放松的，最好别让我再去用脑子。&lt;/p&gt;

&lt;p&gt;毕竟，在我们生活中，有着太多太多被人为创造出来，来吸引我们注意力的东西 —— 偶像剧，大片，综艺，娱乐圈花边，网络游戏，热点消息，诸如此类。&lt;/p&gt;

&lt;p&gt;我们每天光是保持专注，其实，就已经是一件很困难的事情。&lt;/p&gt;

&lt;p&gt;拿热点资讯来说。一条 APP 推送，背后都是一个运营团队，群策群力，经过初稿、初审、复审等一堆环节，有着专业的消费者行为学作支撑，用尽各种文案技法，目的是什么呢？就是吸引你的注意力，点进去。&lt;/p&gt;

&lt;p&gt;同样，一款网络游戏，背后可能是几百人的团队，用最前沿的科技，最详尽的数据，通过声、光、交互、反馈等全方位途径，在各种心理学、行为经济学、认知神经科学等理论指导下，精心打造 —— 目的是什么？为了创造一个虚拟空间，来消磨你的时间。&lt;/p&gt;

&lt;p&gt;一个综艺节目，背后可能是精确到秒的台本，现场五六个机位，多次的彩排、训练，从场景到灯光到音乐，再到人物的服装、语气、动作，全部精心调制，目的就是为了让你沉浸进去，在观看的时候，忘掉时间的流逝。&lt;/p&gt;

&lt;p&gt;而反过来，无论是学习、阅读、思考、写作，这些事情，哪一件有着这么强大的阵势？将「触及成本」降到这么低？&lt;/p&gt;

&lt;p&gt;不存在的。&lt;/p&gt;

&lt;p&gt;这就是消费娱乐文化为我们创造的牢笼。&lt;/p&gt;

&lt;p&gt;而我们正心满意足地，一步步走进去。&lt;/p&gt;

&lt;p&gt;当然，我并不反对适当的娱乐，否则活得也太累了些。&lt;/p&gt;

&lt;p&gt;但是，更常见的现象是什么呢？下班了，一身疲惫，想着「今晚要学习」，忍不住还是把手伸向了手机，刷起微博，玩起王者荣耀。放下手机已是深夜，一边告诉自己「明天再努力吧」，一边洗澡、洗漱，然后睡觉。&lt;/p&gt;

&lt;p&gt;第二天，重复着跟前一天一模一样的生活。&lt;/p&gt;

&lt;p&gt;这是很正常的。前文讲过，一切娱乐产品——影视剧、综艺、游戏，它们背后有着庞大的团队，这些团队的唯一目的，就是用尽各种手段，去降低你触及它们的「阻力」。&lt;/p&gt;

&lt;p&gt;它们会在你视野中不断出现，用各种资讯、消息提醒你，诱导你去点击。一旦点击了，就再也不会给你机会离开。&lt;/p&gt;

&lt;p&gt;想一想，你已经有多久，没有真正为自己的目标做过一些事情了？&lt;/p&gt;

&lt;p&gt;这里面最严重的是什么呢？&lt;/p&gt;

&lt;p&gt;一旦你习惯了这种「低成本、高回报」的刺激，你就很难去做那些「高投入」的事情了。&lt;/p&gt;

&lt;p&gt;人的阈值，是会不断升高的。&lt;/p&gt;

&lt;p&gt;所以，这个时代，我们似乎很难再产生情绪的波动，很难去投入到一样东西上面，很难专注去做一件事情。&lt;/p&gt;

&lt;p&gt;因为，我们的大脑已经被周围的环境，塑造成了一个「高刺激阈值」的对象。&lt;/p&gt;

&lt;p&gt;习惯了轻而易举能获得大量愉悦感，你就会慢慢对这种愉悦感脱敏。&lt;/p&gt;

&lt;p&gt;久而久之，这种强度的愉悦感已经满足不了你了，你需要更高强度、更持续、更深入的刺激。&lt;/p&gt;

&lt;p&gt;相对而言，愉悦感更少、付出更高的行为 —— 比如学习，阅读，思考 —— 自然也就没有人愿意去做。&lt;/p&gt;

&lt;p&gt;这样下去会有什么后果？&lt;/p&gt;

&lt;p&gt;「公众们将会在不久的将来，失去自主思考和判断的能力。最终他们会期望媒体为他们进行思考，并作出判断。」&lt;/p&gt;

&lt;p&gt;这是一个很可怕的事情。&lt;/p&gt;

&lt;p&gt;最后，我想给你几个建议：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;拒绝低幼化的语言刺激&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;什么是低幼化的语言刺激？绝大多数的网络流行语都是。诸如「我也是醉了」「666」「扎心」「你看这个面，它又长又宽」……&lt;/p&gt;

&lt;p&gt;为什么这样说？因为，语言塑造了我们的思维。&lt;/p&gt;

&lt;p&gt;我并不是说「牛逼」就一定不如「厉害」「优秀」「出色」—— 但如果有一天，我们要表达「厉害」，只会说「牛逼」，这岂不是很可怕？&lt;/p&gt;

&lt;p&gt;日常生活中，尽量拨出一定的时间，看深度的、优秀的书籍和文章，保持自己对语言的理解和运用能力。&lt;/p&gt;

&lt;p&gt;「谁掌握了语言，谁就掌握了思想。」&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;拒绝抢夺注意力的低劣产品&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果可以，拒绝从众，拒绝那些肤浅的综艺、影视剧、热点消息、娱乐圈资讯，只看最优秀的作品。&lt;/p&gt;

&lt;p&gt;什么是最优秀的作品？至少，是有突破性的，不反智的，引发思考的，有诚意的，需要动脑子的 —— 《黑镜》就很不错，《权力的游戏》也还可以。&lt;/p&gt;

&lt;p&gt;不要让自己成为「愉悦感」的奴隶。&lt;/p&gt;

&lt;p&gt;不动脑子，能带来短期的愉悦和轻松，但长期来看，它只能导向空虚和无聊。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;为自己设定有意义的目标&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;找到一件有长期收益的事情，并从中获得幸福感 —— 这是一件你需要在30岁前做到的事。&lt;/p&gt;

&lt;p&gt;很多人问我：你不看剧，不看电影，不看综艺，不聚会，不玩游戏，你平时究竟都干些什么？&lt;/p&gt;

&lt;p&gt;我说：学习啊。&lt;/p&gt;

&lt;p&gt;他们问：不会觉得无聊吗？&lt;/p&gt;

&lt;p&gt;每每获得一个新知识，每每将新知识纳入自己的思维体系，所带来的快感是无与伦比的，怎么会感到无聊呢？&lt;/p&gt;

&lt;p&gt;所以，请找到一件能够带给你长期收益和幸福感的事情，把它安排进每天的日程中。&lt;/p&gt;

&lt;p&gt;不需要追求物质收益，也不需要苛求成为领域专家，它的意义，是帮助你对抗慵常、平凡、索然无味的日常生活。让你保持头脑的清醒。&lt;/p&gt;

&lt;p&gt;这就足够了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/ZABClMpkwaTOx1yVAuSekw&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 12 Feb 2019 08:30:00 +0800</pubDate>
        <link>https://bbel.ink/2019/02/%E4%BD%A0%E7%9A%84%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%83%E8%83%BD%E5%8A%9B-%E6%98%AF%E5%A6%82%E4%BD%95%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%A2%AB%E6%AF%81%E6%8E%89%E7%9A%84/</link>
        <guid isPermaLink="true">https://bbel.ink/2019/02/%E4%BD%A0%E7%9A%84%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%83%E8%83%BD%E5%8A%9B-%E6%98%AF%E5%A6%82%E4%BD%95%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%A2%AB%E6%AF%81%E6%8E%89%E7%9A%84/</guid>
        
        <category>my</category>
        
        
      </item>
    
  </channel>
</rss>
